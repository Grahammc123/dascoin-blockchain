diff --git a/.gitignore b/.gitignore
index ac4c2d6..50398ac 100644
--- a/.gitignore
+++ b/.gitignore
@@ -59,3 +59,5 @@ programs/witness_node/genesis.json
 
 tests/generate_empty_blocks/generate_empty_blocks
 
+programs/cli_wallet/nuke_cli_wallet.sh
+
diff --git a/CMakeLists.txt b/CMakeLists.txt
index 5e0b2bc..648f26a 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -152,8 +152,6 @@ endif()
 
 add_subdirectory( libraries )
 add_subdirectory( programs )
-add_subdirectory( tests )
-
 
 if (ENABLE_INSTALLER)
 
diff --git a/libraries/app/api.cpp b/libraries/app/api.cpp
index 5c69fce..7e7fed0 100644
--- a/libraries/app/api.cpp
+++ b/libraries/app/api.cpp
@@ -223,6 +223,7 @@ namespace graphene { namespace app {
        return *_debug_api;
     }
 
+    // TODO: fill this for ALL object types.
     vector<account_id_type> get_relevant_accounts( const object* obj )
     {
        vector<account_id_type> result;
@@ -392,13 +393,13 @@ namespace graphene { namespace app {
        return result;
     }
 
-    vector<operation_history_object> history_api::get_account_history( account_id_type account, 
-                                                                       operation_history_id_type stop, 
-                                                                       unsigned limit, 
+    vector<operation_history_object> history_api::get_account_history( account_id_type account,
+                                                                       operation_history_id_type stop,
+                                                                       unsigned limit,
                                                                        operation_history_id_type start ) const
     {
        FC_ASSERT( _app.chain_database() );
-       const auto& db = *_app.chain_database();       
+       const auto& db = *_app.chain_database();
        FC_ASSERT( limit <= 100 );
        vector<operation_history_object> result;
        const auto& stats = account(db).statistics(db);
@@ -406,7 +407,7 @@ namespace graphene { namespace app {
        const account_transaction_history_object* node = &stats.most_recent_op(db);
        if( start == operation_history_id_type() )
           start = node->operation_id;
-          
+
        while(node && node->operation_id.instance.value > stop.instance.value && result.size() < limit)
        {
           if( node->operation_id.instance.value <= start.instance.value )
@@ -415,13 +416,13 @@ namespace graphene { namespace app {
              node = nullptr;
           else node = &node->next(db);
        }
-       
+
        return result;
     }
-    
-    vector<operation_history_object> history_api::get_relative_account_history( account_id_type account, 
-                                                                                uint32_t stop, 
-                                                                                unsigned limit, 
+
+    vector<operation_history_object> history_api::get_relative_account_history( account_id_type account,
+                                                                                uint32_t stop,
+                                                                                unsigned limit,
                                                                                 uint32_t start) const
     {
        FC_ASSERT( _app.chain_database() );
@@ -433,17 +434,17 @@ namespace graphene { namespace app {
        else start = min( account(db).statistics(db).total_ops, start );
        const auto& hist_idx = db.get_index_type<account_transaction_history_index>();
        const auto& by_seq_idx = hist_idx.indices().get<by_seq>();
-       
+
        auto itr = by_seq_idx.upper_bound( boost::make_tuple( account, start ) );
        auto itr_stop = by_seq_idx.lower_bound( boost::make_tuple( account, stop ) );
        --itr;
-       
+
        while ( itr != itr_stop && result.size() < limit )
        {
           result.push_back( itr->operation_id(db) );
           --itr;
        }
-       
+
        return result;
     }
 
@@ -479,14 +480,14 @@ namespace graphene { namespace app {
        }
        return result;
     } FC_CAPTURE_AND_RETHROW( (a)(b)(bucket_seconds)(start)(end) ) }
-    
+
     crypto_api::crypto_api(){};
-    
+
     blind_signature crypto_api::blind_sign( const extended_private_key_type& key, const blinded_hash& hash, int i )
     {
        return fc::ecc::extended_private_key( key ).blind_sign( hash, i );
     }
-         
+
     signature_type crypto_api::unblind_signature( const extended_private_key_type& key,
                                                      const extended_public_key_type& bob,
                                                      const blind_signature& sig,
@@ -495,32 +496,32 @@ namespace graphene { namespace app {
     {
        return fc::ecc::extended_private_key( key ).unblind_signature( extended_public_key( bob ), sig, hash, i );
     }
-                                                               
+
     commitment_type crypto_api::blind( const blind_factor_type& blind, uint64_t value )
     {
        return fc::ecc::blind( blind, value );
     }
-   
+
     blind_factor_type crypto_api::blind_sum( const std::vector<blind_factor_type>& blinds_in, uint32_t non_neg )
     {
        return fc::ecc::blind_sum( blinds_in, non_neg );
     }
-   
+
     bool crypto_api::verify_sum( const std::vector<commitment_type>& commits_in, const std::vector<commitment_type>& neg_commits_in, int64_t excess )
     {
        return fc::ecc::verify_sum( commits_in, neg_commits_in, excess );
     }
-    
+
     verify_range_result crypto_api::verify_range( const commitment_type& commit, const std::vector<char>& proof )
     {
        verify_range_result result;
        result.success = fc::ecc::verify_range( result.min_val, result.max_val, commit, proof );
        return result;
     }
-    
-    std::vector<char> crypto_api::range_proof_sign( uint64_t min_value, 
-                                                    const commitment_type& commit, 
-                                                    const blind_factor_type& commit_blind, 
+
+    std::vector<char> crypto_api::range_proof_sign( uint64_t min_value,
+                                                    const commitment_type& commit,
+                                                    const blind_factor_type& commit_blind,
                                                     const blind_factor_type& nonce,
                                                     int8_t base10_exp,
                                                     uint8_t min_bits,
@@ -528,23 +529,23 @@ namespace graphene { namespace app {
     {
        return fc::ecc::range_proof_sign( min_value, commit, commit_blind, nonce, base10_exp, min_bits, actual_value );
     }
-                               
+
     verify_range_proof_rewind_result crypto_api::verify_range_proof_rewind( const blind_factor_type& nonce,
-                                                                            const commitment_type& commit, 
+                                                                            const commitment_type& commit,
                                                                             const std::vector<char>& proof )
     {
        verify_range_proof_rewind_result result;
-       result.success = fc::ecc::verify_range_proof_rewind( result.blind_out, 
-                                                            result.value_out, 
-                                                            result.message_out, 
-                                                            nonce, 
-                                                            result.min_val, 
-                                                            result.max_val, 
-                                                            const_cast< commitment_type& >( commit ), 
+       result.success = fc::ecc::verify_range_proof_rewind( result.blind_out,
+                                                            result.value_out,
+                                                            result.message_out,
+                                                            nonce,
+                                                            result.min_val,
+                                                            result.max_val,
+                                                            const_cast< commitment_type& >( commit ),
                                                             proof );
        return result;
     }
-                                    
+
     range_proof_info crypto_api::range_get_info( const std::vector<char>& proof )
     {
        return fc::ecc::range_get_info( proof );
diff --git a/libraries/app/application.cpp b/libraries/app/application.cpp
index 6446448..554eb36 100644
--- a/libraries/app/application.cpp
+++ b/libraries/app/application.cpp
@@ -78,29 +78,60 @@ namespace bpo = boost::program_options;
 namespace detail {
 
    genesis_state_type create_example_genesis() {
-      auto nathan_key = fc::ecc::private_key::regenerate(fc::sha256::hash(string("nathan")));
-      dlog("Allocating all stake to ${key}", ("key", utilities::key_to_wif(nathan_key)));
       genesis_state_type initial_state;
+
       initial_state.initial_parameters.current_fees = fee_schedule::get_default();//->set_all_fees(GRAPHENE_BLOCKCHAIN_PRECISION);
       initial_state.initial_active_witnesses = GRAPHENE_DEFAULT_MIN_WITNESS_COUNT;
       initial_state.initial_timestamp = time_point_sec(time_point::now().sec_since_epoch() /
             initial_state.initial_parameters.block_interval *
             initial_state.initial_parameters.block_interval);
+
+      auto master_key = fc::ecc::private_key::regenerate(fc::sha256::hash("sys.master"));
+      initial_state.initial_accounts.emplace_back("sys.master",
+                                                  master_key.get_public_key(),
+                                                  master_key.get_public_key(),
+                                                  true);
+
+      // Initial witness accounts:
       for( uint64_t i = 0; i < initial_state.initial_active_witnesses; ++i )
       {
-         auto name = "init"+fc::to_string(i);
+         auto name = "sys.witness"+fc::to_string(i);
+         auto witness_key = fc::ecc::private_key::regenerate(fc::sha256::hash(name));
          initial_state.initial_accounts.emplace_back(name,
-                                                     nathan_key.get_public_key(),
-                                                     nathan_key.get_public_key(),
+                                                     witness_key.get_public_key(),
+                                                     witness_key.get_public_key(),
                                                      true);
-         initial_state.initial_committee_candidates.push_back({name});
-         initial_state.initial_witness_candidates.push_back({name, nathan_key.get_public_key()});
+         initial_state.initial_witness_candidates.push_back({name, witness_key.get_public_key()});
       }
 
-      initial_state.initial_accounts.emplace_back("nathan", nathan_key.get_public_key());
-      initial_state.initial_balances.push_back({nathan_key.get_public_key(),
+      // Initial board members:
+      initial_state.initial_committee_candidates.push_back({"sys.master"});
+
+      // Initial balances:
+      initial_state.initial_balances.push_back({master_key.get_public_key(),
                                                 GRAPHENE_SYMBOL,
                                                 GRAPHENE_MAX_SHARE_SUPPLY});
+
+      auto lic_issuer_key = fc::ecc::private_key::regenerate(fc::sha256::hash(string("sys.license-issuer")));
+      initial_state.initial_accounts.emplace_back("sys.license-issuer",
+                                                  lic_issuer_key.get_public_key(),
+                                                  lic_issuer_key.get_public_key(),
+                                                  true);
+      initial_state.initial_license_issuing_authority = {"sys.license-issuer"};
+
+      auto lic_auth_key = fc::ecc::private_key::regenerate(fc::sha256::hash(string("sys.license-authenticator")));
+      initial_state.initial_accounts.emplace_back("sys.license-authenticator",
+                                                  lic_auth_key.get_public_key(),
+                                                  lic_auth_key.get_public_key(),
+                                                  true);
+      initial_state.initial_license_authentication_authority = {"sys.license-authenticator"};
+
+      auto faucet_key = fc::ecc::private_key::regenerate(fc::sha256::hash(string("sys.faucet")));
+      initial_state.initial_accounts.emplace_back("sys.faucet",
+                                                  faucet_key.get_public_key(),
+                                                  faucet_key.get_public_key(),
+                                                  true);
+
       initial_state.initial_chain_id = fc::sha256::hash( "BOGUS" );
 
       return initial_state;
@@ -468,7 +499,7 @@ namespace detail {
             const auto& witness = blk_msg.block.witness(*_chain_db);
             const auto& witness_account = witness.witness_account(*_chain_db);
             auto last_irr = _chain_db->get_dynamic_global_properties().last_irreversible_block_num;
-            ilog("Got block: #${n} time: ${t} latency: ${l} ms from: ${w}  irreversible: ${i} (-${d})", 
+            ilog("Got block: #${n} time: ${t} latency: ${l} ms from: ${w}  irreversible: ${i} (-${d})",
                  ("t",blk_msg.block.timestamp)
                  ("n", blk_msg.block.block_num())
                  ("l", (latency.count()/1000))
@@ -563,7 +594,7 @@ namespace detail {
 
          result.reserve(limit);
          block_id_type last_known_block_id;
-         
+
          if (blockchain_synopsis.empty() ||
              (blockchain_synopsis.size() == 1 && blockchain_synopsis[0] == block_id_type()))
          {
@@ -624,13 +655,13 @@ namespace detail {
       }
 
       /**
-       * Returns a synopsis of the blockchain used for syncing.  This consists of a list of 
+       * Returns a synopsis of the blockchain used for syncing.  This consists of a list of
        * block hashes at intervals exponentially increasing towards the genesis block.
        * When syncing to a peer, the peer uses this data to determine if we're on the same
        * fork as they are, and if not, what blocks they need to send us to get us on their
        * fork.
        *
-       * In the over-simplified case, this is a straighforward synopsis of our current 
+       * In the over-simplified case, this is a straighforward synopsis of our current
        * preferred blockchain; when we first connect up to a peer, this is what we will be sending.
        * It looks like this:
        *   If the blockchain is empty, it will return the empty list.
@@ -646,7 +677,7 @@ namespace detail {
        *     the last item in the list will be the hash of the most recent block on our preferred chain
        * so if the blockchain had 26 blocks labeled a - z, the synopsis would be:
        *    a n u x z
-       * the idea being that by sending a small (<30) number of block ids, we can summarize a huge 
+       * the idea being that by sending a small (<30) number of block ids, we can summarize a huge
        * blockchain.  The block ids are more dense near the end of the chain where because we are
        * more likely to be almost in sync when we first connect, and forks are likely to be short.
        * If the peer we're syncing with in our example is on a fork that started at block 'v',
@@ -661,27 +692,27 @@ namespace detail {
        * no reason to fetch the blocks.
        *
        * Second, when a peer replies to our initial synopsis and gives us a list of the blocks they think
-       * we are missing, they only send a chunk of a few thousand blocks at once.  After we get those 
+       * we are missing, they only send a chunk of a few thousand blocks at once.  After we get those
        * block ids, we need to request more blocks by sending another synopsis (we can't just say "send me
        * the next 2000 ids" because they may have switched forks themselves and they don't track what
        * they've sent us).  For faster performance, we want to get a fairly long list of block ids first,
        * then start downloading the blocks.
        * The peer doesn't handle these follow-up block id requests any different from the initial request;
        * it treats the synopsis we send as our blockchain and bases its response entirely off that.  So to
-       * get the response we want (the next chunk of block ids following the last one they sent us, or, 
+       * get the response we want (the next chunk of block ids following the last one they sent us, or,
        * failing that, the shortest fork off of the last list of block ids they sent), we need to construct
        * a synopsis as if our blockchain was made up of:
        *    1. the blocks in our block chain up to the fork point (if there is a fork) or the head block (if no fork)
        *    2. the blocks we've already pushed from their fork (if there's a fork)
        *    3. the block ids they've previously sent us
-       * Segment 3 is handled in the p2p code, it just tells us the number of blocks it has (in 
+       * Segment 3 is handled in the p2p code, it just tells us the number of blocks it has (in
        * number_of_blocks_after_reference_point) so we can leave space in the synopsis for them.
        * We're responsible for constructing the synopsis of Segments 1 and 2 from our active blockchain and
        * fork database.  The reference_point parameter is the last block from that peer that has been
        * successfully pushed to the blockchain, so that tells us whether the peer is on a fork or on
        * the main chain.
        */
-      virtual std::vector<item_hash_t> get_blockchain_synopsis(const item_hash_t& reference_point, 
+      virtual std::vector<item_hash_t> get_blockchain_synopsis(const item_hash_t& reference_point,
                                                                uint32_t number_of_blocks_after_reference_point) override
       { try {
           std::vector<item_hash_t> synopsis;
@@ -706,13 +737,13 @@ namespace detail {
 
               if (reference_point_block_num < low_block_num)
               {
-                // we're on the same fork (at least as far as reference_point) but we've passed 
-                // reference point and could no longer undo that far if we diverged after that 
+                // we're on the same fork (at least as far as reference_point) but we've passed
+                // reference point and could no longer undo that far if we diverged after that
                 // block.  This should probably only happen due to a race condition where
-                // the network thread calls this function, and then immediately pushes a bunch of blocks, 
+                // the network thread calls this function, and then immediately pushes a bunch of blocks,
                 // then the main thread finally processes this function.
                 // with the current framework, there's not much we can do to tell the network
-                // thread what our current head block is, so we'll just pretend that 
+                // thread what our current head block is, so we'll just pretend that
                 // our head is actually the reference point.
                 // this *may* enable us to fetch blocks that we're unable to push, but that should
                 // be a rare case (and correctly handled)
@@ -756,7 +787,7 @@ namespace detail {
               if (non_fork_high_block_num < low_block_num)
               {
                 wlog("Unable to generate a usable synopsis because the peer we're generating it for forked too long ago "
-                     "(our chains diverge after block #${non_fork_high_block_num} but only undoable to block #${low_block_num})", 
+                     "(our chains diverge after block #${non_fork_high_block_num} but only undoable to block #${low_block_num})",
                      ("low_block_num", low_block_num)
                      ("non_fork_high_block_num", non_fork_high_block_num));
                 FC_THROW_EXCEPTION(graphene::net::block_older_than_undo_history, "Peer is are on a fork I'm unable to switch to");
@@ -773,11 +804,11 @@ namespace detail {
           }
 
           // at this point:
-          // low_block_num is the block before the first block we can undo, 
+          // low_block_num is the block before the first block we can undo,
           // non_fork_high_block_num is the block before the fork (if the peer is on a fork, or otherwise it is the same as high_block_num)
           // high_block_num is the block number of the reference block, or the end of the chain if no reference provided
 
-          // true_high_block_num is the ending block number after the network code appends any item ids it 
+          // true_high_block_num is the ending block number after the network code appends any item ids it
           // knows about that we don't
           uint32_t true_high_block_num = high_block_num + number_of_blocks_after_reference_point;
           do
diff --git a/libraries/app/database_api.cpp b/libraries/app/database_api.cpp
index 734d68b..447e4bf 100644
--- a/libraries/app/database_api.cpp
+++ b/libraries/app/database_api.cpp
@@ -139,7 +139,13 @@ class database_api_impl : public std::enable_shared_from_this<database_api_impl>
       // Blinded balances
       vector<blinded_balance_object> get_blinded_balances( const flat_set<commitment_type>& commitments )const;
 
-   //private:
+      // Licenses:
+      vector<optional<license_type_object>> get_license_types(const vector<license_type_id_type>& license_type_ids) const;
+      vector<optional<license_request_object>> get_license_requests(const vector<license_request_id_type>& license_req_ids)const;
+
+      //Cycles:
+      share_type get_account_cycle_balance(const account_id_type id)const;
+
       template<typename T>
       void subscribe_to_item( const T& i )const
       {
@@ -163,6 +169,83 @@ class database_api_impl : public std::enable_shared_from_this<database_api_impl>
          return _subscribe_filter.contains( i );
       }
 
+      // TODO: figure out some way to use copy.
+      template<typename IndexType, typename IndexBy>
+      vector<typename IndexType::object_type> list_objects( size_t limit ) const
+      {
+         const auto& idx = _db.get_index_type<IndexType>().indices().get<IndexBy>();
+
+         vector<typename IndexType::object_type> result;
+         result.reserve(limit);
+
+         auto itr = idx.begin();
+
+         while(limit-- && itr != idx.end())
+            result.emplace_back(*itr++);
+
+         return result;
+      }
+
+      template<typename IndexType, typename IndexBy>
+      vector<typename IndexType::object_type> list_bounded_objects_indexed_by_string( const string& lower_bound,
+                                                                                     uint32_t limit )
+      {
+         vector<typename IndexType::object_type> result;
+         result.reserve(limit);
+
+         const auto& idx = _db.get_index_type<IndexType>().indices().get<IndexBy>();
+
+         auto itr = idx.lower_bound(lower_bound);
+
+         if( lower_bound == "" )
+            itr = idx.begin();
+
+         while(limit-- && itr != idx.end())
+            result.emplace_back(*itr++);
+
+         return result;
+      }
+
+      // TODO: refactor into template methods.
+      template<typename IndexType, typename IndexBy>
+      vector<typename IndexType::object_type> list_bounded_objects_indexed_by_num( const uint32_t amount,
+                                                                                   uint32_t limit )
+      {
+         vector<typename IndexType::object_type> result;
+         result.reserve(limit);
+
+         const auto& idx = _db.get_index_type<IndexType>().indices().get<IndexBy>();
+
+         auto itr = idx.lower_bound(amount);
+
+         if( amount == 0 )
+            itr = idx.begin();
+
+         while(limit-- && itr != idx.end())
+            result.emplace_back(*itr++);
+
+         return result;
+      }
+
+      template<typename IdType, typename IndexType, typename IndexBy>
+      vector<optional<typename IndexType::object_type> > lookup_string_or_id(const vector<string>& str_or_id)const
+      {
+         const auto& idx = _db.get_index_type<IndexType>().indices().get<IndexBy>();
+         vector<optional<typename IndexType::object_type> > result;
+         result.reserve(str_or_id.size());
+         std::transform(str_or_id.begin(), str_or_id.end(), std::back_inserter(result),
+                        [this, &idx](const string& str_or_id) -> optional<typename IndexType::object_type> {
+            if( !str_or_id.empty() && std::isdigit(str_or_id[0]) )
+            {
+               auto ptr = _db.find(variant(str_or_id).as<IdType>());
+               return ptr == nullptr? optional<typename IndexType::object_type>() : *ptr;
+            }
+            auto itr = idx.find(str_or_id);
+            return itr == idx.end()? optional<typename IndexType::object_type>() : *itr;
+         });
+         return result;
+      }
+
       void broadcast_updates( const vector<variant>& updates );
 
       /** called every time a block is applied to report the objects that were changed */
@@ -1751,6 +1834,110 @@ vector<blinded_balance_object> database_api_impl::get_blinded_balances( const fl
 
 //////////////////////////////////////////////////////////////////////
 //                                                                  //
+// Licenses:                                                        //
+//                                                                  //
+//////////////////////////////////////////////////////////////////////
+
+// TODO: refactor these two into template functions.
+
+vector<optional<license_type_object>> database_api_impl::get_license_types(const vector<license_type_id_type>& license_type_ids)const
+{
+   vector<optional<license_type_object>> result;
+   result.reserve(license_type_ids.size());
+   std::transform(license_type_ids.begin(), license_type_ids.end(), std::back_inserter(result),
+                  [this](license_type_id_type id) -> optional<license_type_object> {
+      if(auto o = _db.find(id))
+      {
+         subscribe_to_item( id );
+         return *o;
+      }
+      return {};
+   });
+   return result;
+}
+
+vector<optional<license_request_object>> database_api_impl::get_license_requests(const vector<license_request_id_type>& license_req_ids)const
+{
+   vector<optional<license_request_object>> result;
+   result.reserve(license_req_ids.size());
+   std::transform(license_req_ids.begin(), license_req_ids.end(), std::back_inserter(result),
+                  [this](license_request_id_type id) -> optional<license_request_object> {
+      if(auto o = _db.find(id))
+      {
+         subscribe_to_item( id );
+         return *o;
+      }
+      return {};
+   });
+   return result;
+}
+
+vector<license_type_object> database_api::list_license_types_by_name( const string& lower_bound_name,
+                                                                      uint32_t limit ) const
+{
+   FC_ASSERT( limit <= 100 );
+   return my->list_bounded_objects_indexed_by_string<license_type_index, by_name>( lower_bound_name, limit );
+}
+
+vector<license_type_object> database_api::list_license_types_by_amount( const uint32_t lower_bound_amount,
+                                                                        uint32_t limit ) const
+{
+   FC_ASSERT( limit <= 100 );
+   return my->list_bounded_objects_indexed_by_num<license_type_index, by_amount>( lower_bound_amount, limit );
+}
+
+vector<optional<license_type_object>> database_api::lookup_license_type_names(const vector<string>& names_or_ids)const
+{
+   return my->lookup_string_or_id<license_type_id_type, license_type_index, by_name>( names_or_ids );
+}
+
+vector<optional<license_type_object>> database_api::get_license_types(const vector<license_type_id_type>& vec_ids) const
+{
+   return my->get_license_types( vec_ids );
+}
+
+vector<optional<license_request_object>> database_api::get_license_requests(const vector<license_request_id_type>& vec_ids) const
+{
+   return my->get_license_requests( vec_ids );
+}
+
+vector<license_request_object> database_api::list_license_requests_by_type(uint32_t limit) const
+{
+   return my->list_objects<license_request_index, by_license_type_id>( limit );
+}
+
+vector<license_request_object> database_api::list_license_requests_by_expiration(uint32_t limit) const
+{
+   return my->list_objects<license_request_index, by_expiration>( limit );
+}
+
+//////////////////////////////////////////////////////////////////////
+//                                                                  //
+// Cycles:                                                          //
+//                                                                  //
+//////////////////////////////////////////////////////////////////////
+
+share_type database_api::get_account_cycle_balance( const account_id_type id )const
+{
+   return my->get_account_cycle_balance( id );
+}
+
+share_type database_api_impl::get_account_cycle_balance( const account_id_type id )const
+{
+   try
+   {
+      const auto& idx = _db.get_index_type<account_cycle_balance_index>().indices().get<by_account_id>();
+      const auto& it = idx.find( id );
+
+      if (it != idx.end())
+         return it->balance;
+      return 0;
+   }
+   FC_CAPTURE_AND_RETHROW( (id) )
+}
+
+//////////////////////////////////////////////////////////////////////
+//                                                                  //
 // Private methods                                                  //
 //                                                                  //
 //////////////////////////////////////////////////////////////////////
diff --git a/libraries/app/impacted.cpp b/libraries/app/impacted.cpp
index 8578742..8bf528d 100644
--- a/libraries/app/impacted.cpp
+++ b/libraries/app/impacted.cpp
@@ -152,6 +152,22 @@ struct get_impacted_account_visitor
       _impacted.insert( op.committee_member_account );
    }
    void operator()( const committee_member_update_global_parameters_operation& op ) {}
+   void operator()( const committee_member_update_license_issuer_operation& op)
+   {
+      _impacted.insert( op.license_issuer );
+   }
+
+   void operator()( const committee_member_update_license_authenticator_operation& op)
+   {
+      _impacted.insert( op.license_authenticator );
+   }
+
+   void operator()( const license_type_create_operation& op ) {}
+   void operator()( const license_type_edit_operation& op ) {}
+   void operator()( const license_type_delete_operation& op ) {}
+   void operator()( const license_request_operation& op ) {}
+   void operator()( const license_approve_operation& op ) {}  // TODO: check if this should be impacting an account.
+   void operator()( const license_deny_operation& op ) {}
 
    void operator()( const vesting_balance_create_operation& op )
    {
diff --git a/libraries/app/include/graphene/app/database_api.hpp b/libraries/app/include/graphene/app/database_api.hpp
index 95ce16d..b7d7934 100644
--- a/libraries/app/include/graphene/app/database_api.hpp
+++ b/libraries/app/include/graphene/app/database_api.hpp
@@ -35,6 +35,7 @@
 #include <graphene/chain/chain_property_object.hpp>
 #include <graphene/chain/committee_member_object.hpp>
 #include <graphene/chain/confidential_object.hpp>
+#include <graphene/chain/license_objects.hpp>
 #include <graphene/chain/market_object.hpp>
 #include <graphene/chain/operation_history_object.hpp>
 #include <graphene/chain/proposal_object.hpp>
@@ -555,6 +556,82 @@ class database_api
        */
       vector<blinded_balance_object> get_blinded_balances( const flat_set<commitment_type>& commitments )const;
 
+      //////////////////////////
+      //                      //
+      //  LICENSES:           //
+      //                      //
+      //////////////////////////
+
+      /**
+       * @brief Get a list of license types based on id's.
+       * @param license_type_ids Id's of the license types to retrieve.
+       * @return The license types corresponding to the provided id's.
+       *
+       * This function has semantics identical to @ref get_objects.
+       */
+      vector<optional<license_type_object>> get_license_types(const vector<license_type_id_type>& license_type_ids)const;
+
+      /**
+       * @brief Get a list of license requests sorted by id.
+       * @param license_req_ids Id's of the requests to receive.
+       * @return The requests corresponding to the provided id's.
+       *
+       * This function has semantics identical to @ref get_objects.
+       */
+      vector<optional<license_request_object>> get_license_requests(const vector<license_request_id_type>& license_req_ids)const;
+
+      /**
+       * @brief Get license types active on the blockchain by name.
+       * @param lower_bound_symbol Lower bound of license type names to retrieve
+       * @param limit Maximum number of license types to fetch (must not exceed 100)
+       * @return The license types found
+       */
+      vector<license_type_object> list_license_types_by_name(const string& lower_bound_name, uint32_t limit)const;
+
+      /**
+       * @brief Get license types active on the blockchain by amount.
+       * @param lower_bound_symbol Lower bound of license type names to retrieve.
+       * @param limit Maximum number of license types to fetch (must not exceed 100).
+       *
+       * @return The license types found.
+       */
+      vector<license_type_object> list_license_types_by_amount(const uint32_t lower_bound_amount, uint32_t limit)const;
+
+      /**
+       * @brief Get a list of license types by names
+       * @param asset_symbols Symbols or stringified IDs of the assets to retrieve
+       * @return The assets corresponding to the provided symbols or IDs
+       *
+       * This function has semantics identical to @ref get_objects
+       */
+      vector<optional<license_type_object>> lookup_license_type_names(const vector<string>& names_or_ids)const;
+
+      /**
+       * @brief Get all license request objects on the blockchain by type.
+       * @param limit Maximum number of objects to fetch.
+       * @return The objects found.
+       */
+      vector<license_request_object> list_license_requests_by_type(uint32_t limit)const;
+
+      /**
+       * @brief Get all license request objects on the blockchain by expiration time.
+       * @param limit Maximum number of objects to fetch.
+       * @return The objects found.
+       */
+      vector<license_request_object> list_license_requests_by_expiration(uint32_t limit)const;
+
+      /////////////
+      // CYCLES: //
+      /////////////
+
+      /**
+       * @brief Get the amount of cycles in an acount with the given ID. If the account has no cycle balance object,
+       * the method will return 0.
+       * @param  account_id ID of the account to check.
+       * @return            Amount of cycles attached to the account.
+       */
+      share_type get_account_cycle_balance(const account_id_type account_id)const;
+
    private:
       std::shared_ptr< database_api_impl > my;
 };
@@ -657,4 +734,16 @@ FC_API(graphene::app::database_api,
 
    // Blinded balances
    (get_blinded_balances)
+
+   // Licenses
+   (get_license_types)
+   (get_license_requests)
+   (list_license_types_by_name)
+   (list_license_types_by_amount)
+   (lookup_license_type_names)
+   (list_license_requests_by_type)
+   (list_license_requests_by_expiration)
+
+   // Cycles
+   (get_account_cycle_balance)
 )
diff --git a/libraries/chain/CMakeLists.txt b/libraries/chain/CMakeLists.txt
index 9cc4285..9e1a4cd 100644
--- a/libraries/chain/CMakeLists.txt
+++ b/libraries/chain/CMakeLists.txt
@@ -19,6 +19,7 @@ if( GRAPHENE_DISABLE_UNITY_BUILD )
         db_market.cpp
         db_update.cpp
         db_witness_schedule.cpp
+        db_license.cpp
       )
    message( STATUS "Graphene database unity build disabled" )
 else( GRAPHENE_DISABLE_UNITY_BUILD )
@@ -56,6 +57,7 @@ add_library( graphene_chain
              protocol/fee_schedule.cpp
              protocol/confidential.cpp
              protocol/vote.cpp
+             protocol/license.cpp
 
              genesis_state.cpp
              get_config.cpp
@@ -76,6 +78,7 @@ add_library( graphene_chain
              withdraw_permission_evaluator.cpp
              worker_evaluator.cpp
              confidential_evaluator.cpp
+             license_evaluator.cpp
              special_authority.cpp
              buyback.cpp
 
@@ -89,6 +92,8 @@ add_library( graphene_chain
 
              is_authorized_asset.cpp
 
+             license_objects.cpp
+
              ${HEADERS}
              "${CMAKE_CURRENT_BINARY_DIR}/include/graphene/chain/hardfork.hpp"
            )
diff --git a/libraries/chain/account_object.cpp b/libraries/chain/account_object.cpp
index 90d9769..a0b416a 100644
--- a/libraries/chain/account_object.cpp
+++ b/libraries/chain/account_object.cpp
@@ -254,6 +254,28 @@ void account_member_index::object_modified(const object& after)
 
 }
 
+void account_cycle_balance_object::adjust_cycle_balance(const share_type balance_delta)
+{
+  balance += balance_delta;
+}
+
+void account_cycle_balance_object::adjust_upgrades(const uint8_t new_upgrades)
+{
+  remaining_upgrades = new_upgrades;
+}
+
+/*void account_statistics_object::process_db_maintenance(database& db,
+                                                       const optional<license_type_id_type> license_type,
+                                                       const dynamic_global_property_object& dgpo)
+{
+  if (remaining_upgrades > 0)
+  {
+    ilog("Performing test account cycle upgrade!");
+    remaining_upgrades--;
+    cycles *= 2;
+  }
+}*/
+
 void account_referrer_index::object_inserted( const object& obj )
 {
 }
diff --git a/libraries/chain/committee_member_evaluator.cpp b/libraries/chain/committee_member_evaluator.cpp
index 4e7eb82..7495b30 100644
--- a/libraries/chain/committee_member_evaluator.cpp
+++ b/libraries/chain/committee_member_evaluator.cpp
@@ -89,4 +89,36 @@ void_result committee_member_update_global_parameters_evaluator::do_apply(const
    return void_result();
 } FC_CAPTURE_AND_RETHROW( (o) ) }
 
+void_result committee_member_update_license_issuer_evaluator::do_evaluate(const committee_member_update_license_issuer_operation& o)
+{ try {
+   // Check if the license issuer is a lifetime member.
+   FC_ASSERT( db().get(o.license_issuer).is_lifetime_member() );
+   return void_result();
+} FC_CAPTURE_AND_RETHROW( (o) )}
+
+void_result committee_member_update_license_issuer_evaluator::do_apply(const committee_member_update_license_issuer_operation& o)
+{ try {
+   // Modifiy the global properties object and set the new license issuing authority.
+   db().modify(db().get_global_properties(), [&o](global_property_object& p) {
+      p.authorities.license_issuer = o.license_issuer;
+   });
+   return void_result();
+} FC_CAPTURE_AND_RETHROW( (o) )}
+
+void_result committee_member_update_license_authenticator_evaluator::do_evaluate(const committee_member_update_license_authenticator_operation& o)
+{ try {
+   // Check if the license authenticator is a lifetime member.
+   FC_ASSERT( db().get(o.license_authenticator).is_lifetime_member() );
+   return void_result();
+} FC_CAPTURE_AND_RETHROW( (o) )}
+
+void_result committee_member_update_license_authenticator_evaluator::do_apply(const committee_member_update_license_authenticator_operation& o)
+{ try {
+   // Modifiy the global properties object and set the new license authentication authority.
+   db().modify(db().get_global_properties(), [&o](global_property_object& p) {
+      p.authorities.license_authenticator = o.license_authenticator;
+   });
+   return void_result();
+} FC_CAPTURE_AND_RETHROW( (o) )}
+
 } } // graphene::chain
diff --git a/libraries/chain/database.cpp b/libraries/chain/database.cpp
index aa9f612..3e01e2e 100644
--- a/libraries/chain/database.cpp
+++ b/libraries/chain/database.cpp
@@ -32,3 +32,4 @@
 #include "db_market.cpp"
 #include "db_update.cpp"
 #include "db_witness_schedule.cpp"
+#include "db_license.cpp"
diff --git a/libraries/chain/db_balance.cpp b/libraries/chain/db_balance.cpp
index a70f077..06e1655 100644
--- a/libraries/chain/db_balance.cpp
+++ b/libraries/chain/db_balance.cpp
@@ -59,7 +59,7 @@ void database::adjust_balance(account_id_type account, asset delta )
    auto itr = index.find(boost::make_tuple(account, delta.asset_id));
    if(itr == index.end())
    {
-      FC_ASSERT( delta.amount > 0, "Insufficient Balance: ${a}'s balance of ${b} is less than required ${r}", 
+      FC_ASSERT( delta.amount > 0, "Insufficient Balance: ${a}'s balance of ${b} is less than required ${r}",
                  ("a",account(*this).name)
                  ("b",to_pretty_string(asset(0,delta.asset_id)))
                  ("r",to_pretty_string(-delta)));
@@ -78,6 +78,46 @@ void database::adjust_balance(account_id_type account, asset delta )
 
 } FC_CAPTURE_AND_RETHROW( (account)(delta) ) }
 
+void database::adjust_cycle_balance(account_id_type account, share_type delta, optional<uint8_t> upgrades)
+{ try {
+
+   if( delta == 0 )
+      return;
+
+   if ( upgrades.valid() )
+      FC_ASSERT( *upgrades > 0, "Upgrades must be increased by a positive amont: upgrades = ${u} ", ("u",upgrades) );
+
+   auto& index = get_index_type<account_cycle_balance_index>().indices().get<by_account_id>();
+   auto itr = index.find(account);
+   if(itr == index.end())
+   {
+      FC_ASSERT( delta > 0, "Insufficient Balance: ${a}'s balance of cycles is less than required ${r}",
+                 ("a",account(*this).name)
+                 ("r",to_pretty_string(-delta)));
+
+      create<account_cycle_balance_object>([account,delta,upgrades](account_cycle_balance_object& b) {
+         b.owner = account;
+         b.balance = delta;
+         if ( upgrades.valid() )
+            b.remaining_upgrades = *upgrades;
+      });
+   } else {
+      if( delta < 0 )
+         FC_ASSERT( itr->get_balance() >= -delta,
+                    "Insufficient Balance: ${a}'s balance of ${b} is less than required ${r}",
+                    ("a",account(*this).name)
+                    ("b",to_pretty_string(itr->get_balance()))
+                    ("r",to_pretty_string(-delta)));
+
+      modify(*itr, [delta,upgrades](account_cycle_balance_object& b) {
+         b.adjust_cycle_balance(delta);
+         if ( upgrades.valid() )
+            b.adjust_upgrades(*upgrades);
+      });
+   }
+
+} FC_CAPTURE_AND_RETHROW( (account)(delta) ) }
+
 optional< vesting_balance_id_type > database::deposit_lazy_vesting(
    const optional< vesting_balance_id_type >& ovbid,
    share_type amount, uint32_t req_vesting_seconds,
diff --git a/libraries/chain/db_block.cpp b/libraries/chain/db_block.cpp
index 8f4f1f1..1cd3af5 100644
--- a/libraries/chain/db_block.cpp
+++ b/libraries/chain/db_block.cpp
@@ -534,6 +534,10 @@ void database::_apply_block( const signed_block& next_block )
    // to be called for header validation?
    update_maintenance_flag( maint_needed );
    update_witness_schedule();
+
+   // Handle completed license requests.
+   assign_licenses();
+
    if( !_node_property_object.debug_updates.empty() )
       apply_debug_updates();
 
@@ -546,7 +550,7 @@ void database::_apply_block( const signed_block& next_block )
 
 void database::notify_changed_objects()
 { try {
-   if( _undo_db.enabled() ) 
+   if( _undo_db.enabled() )
    {
       const auto& head_undo = _undo_db.head();
       vector<object_id_type> changed_ids;  changed_ids.reserve(head_undo.old_values.size());
@@ -667,7 +671,7 @@ const witness_object& database::validate_block_header( uint32_t skip, const sign
    FC_ASSERT( head_block_time() < next_block.timestamp, "", ("head_block_time",head_block_time())("next",next_block.timestamp)("blocknum",next_block.block_num()) );
    const witness_object& witness = next_block.witness(*this);
 
-   if( !(skip&skip_witness_signature) ) 
+   if( !(skip&skip_witness_signature) )
       FC_ASSERT( next_block.validate_signee( witness.signing_key ) );
 
    if( !(skip&skip_witness_schedule_check) )
diff --git a/libraries/chain/db_init.cpp b/libraries/chain/db_init.cpp
index 914b3fa..7e46886 100644
--- a/libraries/chain/db_init.cpp
+++ b/libraries/chain/db_init.cpp
@@ -36,6 +36,7 @@
 #include <graphene/chain/confidential_object.hpp>
 #include <graphene/chain/fba_object.hpp>
 #include <graphene/chain/global_property_object.hpp>
+#include <graphene/chain/license_objects.hpp>  // TODO: move!
 #include <graphene/chain/market_object.hpp>
 #include <graphene/chain/operation_history_object.hpp>
 #include <graphene/chain/proposal_object.hpp>
@@ -54,6 +55,7 @@
 #include <graphene/chain/committee_member_evaluator.hpp>
 #include <graphene/chain/confidential_evaluator.hpp>
 #include <graphene/chain/custom_evaluator.hpp>
+#include <graphene/chain/license_evaluator.hpp>
 #include <graphene/chain/market_evaluator.hpp>
 #include <graphene/chain/proposal_evaluator.hpp>
 #include <graphene/chain/transfer_evaluator.hpp>
@@ -126,6 +128,14 @@ const uint8_t witness_object::type_id;
 const uint8_t worker_object::space_id;
 const uint8_t worker_object::type_id;
 
+const uint8_t license_type_object::space_id;
+const uint8_t license_type_object::type_id;
+
+const uint8_t license_request_object::space_id;
+const uint8_t license_request_object::type_id;
+
+const uint8_t account_cycle_balance_object::space_id;
+const uint8_t account_cycle_balance_object::type_id;
 
 void database::initialize_evaluators()
 {
@@ -171,6 +181,14 @@ void database::initialize_evaluators()
    register_evaluator<transfer_from_blind_evaluator>();
    register_evaluator<blind_transfer_evaluator>();
    register_evaluator<asset_claim_fees_evaluator>();
+   register_evaluator<committee_member_update_license_issuer_evaluator>();
+   register_evaluator<committee_member_update_license_authenticator_evaluator>();
+   register_evaluator<license_type_create_evaluator>();
+   register_evaluator<license_type_edit_evaluator>();
+   register_evaluator<license_type_delete_evaluator>();
+   register_evaluator<license_request_evaluator>();
+   register_evaluator<license_approve_evaluator>();
+   register_evaluator<license_deny_evaluator>();
 }
 
 void database::initialize_indexes()
@@ -216,6 +234,11 @@ void database::initialize_indexes()
    add_index< primary_index< buyback_index                                > >();
 
    add_index< primary_index< simple_index< fba_accumulator_object       > > >();
+
+   add_index<primary_index<license_type_index>>();
+   add_index<primary_index<license_request_index>>();
+
+   add_index<primary_index<account_cycle_balance_index>>();
 }
 
 void database::init_genesis(const genesis_state_type& genesis_state)
@@ -647,6 +670,38 @@ void database::init_genesis(const genesis_state_type& genesis_state)
        apply_operation(genesis_eval_state, std::move(op));
    });
 
+   // Initialize cycle licensing:
+   {
+      ilog("license issuer name: ${name}", ("name", genesis_state.initial_license_issuing_authority.owner_name));
+      ilog("license authenticator name: ${name}", ("name", genesis_state.initial_license_authentication_authority.owner_name));
+
+      account_id_type issuer = get_account_id(genesis_state.initial_license_issuing_authority.owner_name);
+      account_id_type authenticator = get_account_id(genesis_state.initial_license_authentication_authority.owner_name);
+      // Create license issuing authority:
+      committee_member_update_license_issuer_operation issuer_op;
+      issuer_op.license_issuer = issuer;
+      issuer_op.committee_member_account = GRAPHENE_COMMITTEE_ACCOUNT;
+      apply_operation(genesis_eval_state, std::move(issuer_op));
+
+      // Create license authentication authority:
+      committee_member_update_license_authenticator_operation authenticator_op;
+      authenticator_op.license_authenticator = authenticator;
+      authenticator_op.committee_member_account = GRAPHENE_COMMITTEE_ACCOUNT;
+      apply_operation(genesis_eval_state, std::move(authenticator_op));
+
+      create_license_type("standard", 100, 1, 0);
+      create_license_type("manager", 500, 1, 0);
+      create_license_type("pro", 2000, 1, 0);
+      create_license_type("executive", 5000, 2, 0);
+      create_license_type("president", 25000, 3, 0);
+
+      create_license_type("standard-charter", 100, 1, CYCLE_POLICY_CHARTER_MASK);
+      create_license_type("manager-charter", 500, 1, CYCLE_POLICY_CHARTER_MASK);
+      create_license_type("pro-charter", 2000, 1, CYCLE_POLICY_CHARTER_MASK);
+      create_license_type("executive-charter", 5000, 2, CYCLE_POLICY_CHARTER_MASK);
+      create_license_type("president-charter", 25000, 3, CYCLE_POLICY_CHARTER_MASK);
+   }
+
    // Set active witnesses
    modify(get_global_properties(), [&](global_property_object& p) {
       for( uint32_t i = 1; i <= genesis_state.initial_active_witnesses; ++i )
diff --git a/libraries/chain/db_maint.cpp b/libraries/chain/db_maint.cpp
index d515a96..1b3308b 100644
--- a/libraries/chain/db_maint.cpp
+++ b/libraries/chain/db_maint.cpp
@@ -72,12 +72,12 @@ vector<std::reference_wrapper<const typename Index::object_type>> database::sort
    return refs;
 }
 
-template<class... Types>
-void database::perform_account_maintenance(std::tuple<Types...> helpers)
+template<typename IndexType, typename IndexBy, class... HelperTypes>
+void database::perform_helpers(std::tuple<HelperTypes...> helpers)
 {
-   const auto& idx = get_index_type<account_index>().indices().get<by_name>();
-   for( const account_object& a : idx )
-      detail::for_each(helpers, a, detail::gen_seq<sizeof...(Types)>());
+   const auto& idx = get_index_type<IndexType>().indices().get<IndexBy>();
+   for( const typename IndexType::object_type& a : idx )
+      detail::for_each(helpers, a, detail::gen_seq<sizeof...(HelperTypes)>());
 }
 
 /// @brief A visitor for @ref worker_type which calls pay_worker on the worker within
@@ -164,7 +164,7 @@ void database::update_active_witnesses()
    /// accounts that vote for 0 or 1 witness do not get to express an opinion on
    /// the number of witnesses to have (they abstain and are non-voting accounts)
 
-   share_type stake_tally = 0; 
+   share_type stake_tally = 0;
 
    size_t witness_count = 0;
    if( stake_target > 0 )
@@ -716,9 +716,33 @@ void deprecate_annual_members( database& db )
    return;
 }
 
+// TODO: if necessary, turn this into a template method.
+void database::upgrade_cycles()
+{
+   auto& idx = get_index_type<account_cycle_balance_index>();
+   auto itr = idx.indices().get<by_account_id>().begin();
+   while( itr != idx.indices().get<by_account_id>().end() )
+   {
+      modify( *itr, [&]( account_cycle_balance_object& b ){
+         ilog("Upgrading cycles for account ${a}: before = ${o}, after = ${n}",
+              ("a", b.owner)
+              ("o", b.balance)
+              ("n", b.balance*2));
+         b.balance *= 2;
+      });
+      ++itr;
+   }
+}
+
 void database::perform_chain_maintenance(const signed_block& next_block, const global_property_object& global_props)
 {
    const auto& gpo = get_global_properties();
+   const auto& dgpo = get_dynamic_global_properties();
+
+   auto intervals_until_cycle_upgrade =
+      get<dynamic_global_property_object>(dynamic_global_property_id_type()).intervals_until_cycle_upgrade;
+   auto cycle_upgrade_maintenance_int_count =
+      get<global_property_object>(global_property_id_type()).parameters.cycle_upgrade_maintenance_int_count;
 
    distribute_fba_balances(*this);
    create_buyback_orders(*this);
@@ -799,10 +823,7 @@ void database::perform_chain_maintenance(const signed_block& next_block, const g
       }
    } fee_helper(*this, gpo);
 
-   perform_account_maintenance(std::tie(
-      tally_helper,
-      fee_helper
-      ));
+   perform_helpers<account_index, by_name>( std::tie( tally_helper, fee_helper ) );
 
    struct clear_canary {
       clear_canary(vector<uint64_t>& target): target(target){}
@@ -818,6 +839,8 @@ void database::perform_chain_maintenance(const signed_block& next_block, const g
    update_active_witnesses();
    update_active_committee_members();
    update_worker_votes();
+   if ( intervals_until_cycle_upgrade == 0 )
+      upgrade_cycles();
 
    modify(gpo, [this](global_property_object& p) {
       // Remove scaling of account registration fee
@@ -862,14 +885,14 @@ void database::perform_chain_maintenance(const signed_block& next_block, const g
       }
    }
 
-   const dynamic_global_property_object& dgpo = get_dynamic_global_properties();
-
    if( (dgpo.next_maintenance_time < HARDFORK_613_TIME) && (next_maintenance_time >= HARDFORK_613_TIME) )
       deprecate_annual_members(*this);
 
-   modify(dgpo, [next_maintenance_time](dynamic_global_property_object& d) {
+   modify(dgpo,[next_maintenance_time,cycle_upgrade_maintenance_int_count](dynamic_global_property_object& d) {
       d.next_maintenance_time = next_maintenance_time;
       d.accounts_registered_this_interval = 0;
+      if ( --d.intervals_until_cycle_upgrade < 0 )
+         d.intervals_until_cycle_upgrade = cycle_upgrade_maintenance_int_count;
    });
 
    // Reset all BitAsset force settlement volumes to zero
diff --git a/libraries/chain/db_update.cpp b/libraries/chain/db_update.cpp
index 2219136..37e747b 100644
--- a/libraries/chain/db_update.cpp
+++ b/libraries/chain/db_update.cpp
@@ -60,7 +60,7 @@ void database::update_global_dynamic_data( const signed_block& b )
          modify( witness_missed, [&]( witness_object& w ) {
            w.total_missed++;
          });
-      } 
+      }
    }
 
    // dynamic global properties updating
@@ -190,7 +190,7 @@ void database::clear_expired_proposals()
 
 /**
  *  let HB = the highest bid for the collateral  (aka who will pay the most DEBT for the least collateral)
- *  let SP = current median feed's Settlement Price 
+ *  let SP = current median feed's Settlement Price
  *  let LC = the least collateralized call order's swan price (debt/collateral)
  *
  *  If there is no valid price feed or no bids then there is no black swan.
@@ -236,7 +236,7 @@ bool database::check_for_blackswan( const asset_object& mia, bool enable_black_s
     }
 
     auto least_collateral = call_itr->collateralization();
-    if( ~least_collateral >= highest  ) 
+    if( ~least_collateral >= highest  )
     {
        elog( "Black Swan detected: \n"
              "   Least collateralized call: ${lc}  ${~lc}\n"
@@ -250,7 +250,7 @@ bool database::check_for_blackswan( const asset_object& mia, bool enable_black_s
        FC_ASSERT( enable_black_swan, "Black swan was detected during a margin update which is not allowed to trigger a blackswan" );
        globally_settle_asset(mia, ~least_collateral );
        return true;
-    } 
+    }
     return false;
 }
 
@@ -407,8 +407,8 @@ void database::clear_expired_orders()
             }
             try {
                settled += match(*itr, order, settlement_price, max_settlement);
-            } 
-            catch ( const black_swan_exception& e ) { 
+            }
+            catch ( const black_swan_exception& e ) {
                wlog( "black swan detected: ${e}", ("e", e.to_detail_string() ) );
                cancel_order( order );
                break;
@@ -474,4 +474,34 @@ void database::update_withdraw_permissions()
       remove(*permit_index.begin());
 }
 
-} }
+void database::assign_licenses()
+{ try {
+  transaction_evaluation_state assign_context(this);
+  const auto& idx = get_index_type<license_request_index>().indices().get<by_expiration>();
+
+  while ( !idx.empty() && idx.begin()->expiration <= head_block_time() )
+  {
+    const auto& req = *idx.begin();
+    const auto& gpo = get_global_properties();
+    ilog("Appliying license request ${id}", ("id", req.id));
+
+    license_approve_operation op;
+    op.license_authentication_account = gpo.authorities.license_authenticator;
+    op.request = req.id;
+
+    assign_context.skip_fee_schedule_check = true;  // TODO: this is set in limit order cancel, determine why!
+    apply_operation( assign_context, op );
+
+    remove(req);
+
+  }
+} FC_CAPTURE_AND_RETHROW() }
+
+void database::deny_license_request(const license_request_object& req)
+{ try {
+
+  remove(req);
+
+} FC_CAPTURE_AND_RETHROW() }
+
+} }  // namespace database::chain
diff --git a/libraries/chain/include/graphene/chain/account_object.hpp b/libraries/chain/include/graphene/chain/account_object.hpp
index faf59e2..ca05a4e 100644
--- a/libraries/chain/include/graphene/chain/account_object.hpp
+++ b/libraries/chain/include/graphene/chain/account_object.hpp
@@ -86,6 +86,16 @@ namespace graphene { namespace chain {
           * Core fees are paid into the account_statistics_object by this method
           */
          void pay_fee( share_type core_fee, share_type cashback_vesting_threshold );
+
+         /**
+          * Do all operations on a regular db maintenance cycle.
+          * @param db A reference to the object database.
+          * @param license_type A reference to the license type object.
+          * @param dgpo A reference to the dynamic global properties object.
+          */
+         void process_db_maintenance(database& db,
+                                     const optional<license_type_id_type> license_type,
+                                     const dynamic_global_property_object& dgpo);
    };
 
    /**
@@ -109,6 +119,31 @@ namespace graphene { namespace chain {
          void  adjust_balance(const asset& delta);
    };
 
+   /**
+    * @brief Tracks the cycle balance of a single account and connects it to a license.
+    * @ingroup object
+    *
+    */
+   class account_cycle_balance_object : public abstract_object<account_cycle_balance_object>
+   {
+      public:
+         static const uint8_t space_id = implementation_ids;
+         static const uint8_t type_id  = impl_account_cycle_balance_object_type;
+
+         account_id_type owner;
+         share_type balance;
+         uint8_t remaining_upgrades;
+
+         share_type get_balance()const { return balance; }
+         uint8_t get_remaining_upgrades()const { return remaining_upgrades; }
+
+         /**
+          * Adjust the cycle balance of the account.
+          * @param delta The amount by which to change.
+          */
+         void adjust_cycle_balance(const share_type balance_delta);
+         void adjust_upgrades(const uint8_t upgrades);
+   };
 
    /**
     * @brief This class represents an account on the object graph
@@ -210,6 +245,21 @@ namespace graphene { namespace chain {
          special_authority active_special_authority = no_special_authority();
 
          /**
+          * A cycle license the account holds:
+          */
+         optional<license_type_id_type> license;
+
+         /**
+          * This value, if set, overrides the global frequency of the account.
+          */
+         optional<frequency_type> account_frequency;
+
+         /**
+          * Is this a chartered account?
+          */
+         bool is_chartered = false;
+
+         /**
           * This flag is set when the top_n logic sets both authorities,
           * and gets reset when authority or special_authority is set.
           */
@@ -364,6 +414,23 @@ namespace graphene { namespace chain {
     */
    typedef generic_index<account_object, account_multi_index_type> account_index;
 
+   struct by_account_id;
+   typedef multi_index_container<
+      account_cycle_balance_object,
+      indexed_by<
+         ordered_unique< tag<by_id>,
+            member< object, object_id_type, &object::id >
+         >,
+         ordered_non_unique< tag<by_account_id>,
+            member< account_cycle_balance_object, account_id_type, &account_cycle_balance_object::owner>
+         >
+      >
+   > account_cycle_balance_multi_index_type;
+
+   typedef generic_index<
+      account_cycle_balance_object, account_cycle_balance_multi_index_type
+   > account_cycle_balance_index;
+
 }}
 
 FC_REFLECT_DERIVED( graphene::chain::account_object,
@@ -373,7 +440,11 @@ FC_REFLECT_DERIVED( graphene::chain::account_object,
                     (name)(owner)(active)(options)(statistics)(whitelisting_accounts)(blacklisting_accounts)
                     (whitelisted_accounts)(blacklisted_accounts)
                     (cashback_vb)
-                    (owner_special_authority)(active_special_authority)
+                    (owner_special_authority)
+                    (active_special_authority)
+                    (license)
+                    (account_frequency)
+                    (is_chartered)
                     (top_n_control_flags)
                     (allowed_assets)
                     )
@@ -389,6 +460,12 @@ FC_REFLECT_DERIVED( graphene::chain::account_statistics_object,
                     (total_ops)
                     (total_core_in_orders)
                     (lifetime_fees_paid)
-                    (pending_fees)(pending_vested_fees)
+                    (pending_fees)
+                    (pending_vested_fees)
                   )
 
+FC_REFLECT_DERIVED( graphene::chain::account_cycle_balance_object, (graphene::db::object),
+                    (owner)
+                    (balance)
+                    (remaining_upgrades)
+                  )
diff --git a/libraries/chain/include/graphene/chain/committee_member_evaluator.hpp b/libraries/chain/include/graphene/chain/committee_member_evaluator.hpp
index d6ad7b6..2cd22a5 100644
--- a/libraries/chain/include/graphene/chain/committee_member_evaluator.hpp
+++ b/libraries/chain/include/graphene/chain/committee_member_evaluator.hpp
@@ -54,4 +54,28 @@ namespace graphene { namespace chain {
          void_result do_apply( const committee_member_update_global_parameters_operation& o );
    };
 
+   //////////////////////////////////////////////
+   // Evaluators for chain authority updates:  //
+   //////////////////////////////////////////////
+
+   class committee_member_update_license_issuer_evaluator
+      : public evaluator<committee_member_update_license_issuer_evaluator>
+   {
+      public:
+         typedef committee_member_update_license_issuer_operation operation_type;
+
+         void_result do_evaluate( const committee_member_update_license_issuer_operation& o );
+         void_result do_apply( const committee_member_update_license_issuer_operation& o );
+   };
+
+   class committee_member_update_license_authenticator_evaluator
+      : public evaluator<committee_member_update_license_authenticator_evaluator>
+   {
+      public:
+         typedef committee_member_update_license_authenticator_operation operation_type;
+
+         void_result do_evaluate( const committee_member_update_license_authenticator_operation& o );
+         void_result do_apply( const committee_member_update_license_authenticator_operation& o );
+   };
+
 } } // graphene::chain
diff --git a/libraries/chain/include/graphene/chain/config.hpp b/libraries/chain/include/graphene/chain/config.hpp
index 74b7d2b..ffd3737 100644
--- a/libraries/chain/include/graphene/chain/config.hpp
+++ b/libraries/chain/include/graphene/chain/config.hpp
@@ -46,8 +46,8 @@
 #define GRAPHENE_DEFAULT_BLOCK_INTERVAL  5 /* seconds */
 #define GRAPHENE_DEFAULT_MAX_TRANSACTION_SIZE 2048
 #define GRAPHENE_DEFAULT_MAX_BLOCK_SIZE  (GRAPHENE_DEFAULT_MAX_TRANSACTION_SIZE*GRAPHENE_DEFAULT_BLOCK_INTERVAL*200000)
-#define GRAPHENE_DEFAULT_MAX_TIME_UNTIL_EXPIRATION (60*60*24) // seconds,  aka: 1 day
-#define GRAPHENE_DEFAULT_MAINTENANCE_INTERVAL  (60*60*24) // seconds, aka: 1 day
+#define GRAPHENE_DEFAULT_MAX_TIME_UNTIL_EXPIRATION (60*5) // seconds,  aka: 5 minutes
+#define GRAPHENE_DEFAULT_MAINTENANCE_INTERVAL  (60*5) // seconds, aka: 5 minutes
 #define GRAPHENE_DEFAULT_MAINTENANCE_SKIP_SLOTS 3  // number of slots to skip for maintenance interval
 
 #define GRAPHENE_MIN_UNDO_HISTORY 10
@@ -88,8 +88,8 @@
 ///@}
 #define GRAPHENE_DEFAULT_MARGIN_PERIOD_SEC              (30*60*60*24)
 
-#define GRAPHENE_DEFAULT_MIN_WITNESS_COUNT                    (11)
-#define GRAPHENE_DEFAULT_MIN_COMMITTEE_MEMBER_COUNT           (11)
+#define GRAPHENE_DEFAULT_MIN_WITNESS_COUNT                    (1)
+#define GRAPHENE_DEFAULT_MIN_COMMITTEE_MEMBER_COUNT           (1)
 #define GRAPHENE_DEFAULT_MAX_WITNESSES                        (1001) // SHOULD BE ODD
 #define GRAPHENE_DEFAULT_MAX_COMMITTEE                        (1001) // SHOULD BE ODD
 #define GRAPHENE_DEFAULT_MAX_PROPOSAL_LIFETIME_SEC            (60*60*24*7*4) // Four weeks
@@ -170,3 +170,8 @@
 
 // hack for unit test
 #define GRAPHENE_FBA_STEALTH_DESIGNATED_ASSET (asset_id_type(1))
+
+#define GRAPHENE_LICENSE_ISSUE_DEFAULT_EXPIRATION_TIME (5*60)  // Five minutes. TODO: should be 24 hours.
+#define GRAPHENE_MAX_LICENSE_UPGRADE_COUNT (3)
+
+#define GRAPHENE_DEFAULT_CYCLE_UPGRADE_MAINT_INT_COUNT (10)
diff --git a/libraries/chain/include/graphene/chain/database.hpp b/libraries/chain/include/graphene/chain/database.hpp
index 1b72125..801cd5f 100644
--- a/libraries/chain/include/graphene/chain/database.hpp
+++ b/libraries/chain/include/graphene/chain/database.hpp
@@ -295,6 +295,13 @@ namespace graphene { namespace chain {
          void adjust_balance(account_id_type account, asset delta);
 
          /**
+          * @brief Adjsut a particular account's cycle balance by a delta.
+          * @param account ID of the account whose balance should be adjusted.
+          * @param delta   Amount to adjust balance by.
+          */
+         void adjust_cycle_balance(account_id_type account, share_type delta, optional<uint8_t> upgrades_delta);
+
+         /**
           * @brief Helper to make lazy deposit to CDD VBO.
           *
           * If the given optional VBID is not valid(),
@@ -304,7 +311,7 @@ namespace graphene { namespace chain {
           * to newly created VBID and return it.
           *
           * Otherwise, credit amount to ovbid.
-          * 
+          *
           * @return ID of newly created VBO, but only if VBO was created.
           */
          optional< vesting_balance_id_type > deposit_lazy_vesting(
@@ -386,7 +393,6 @@ namespace graphene { namespace chain {
           */
          processed_transaction validate_transaction( const signed_transaction& trx );
 
-
          /** when popping a block, the transactions that were removed get cached here so they
           * can be reapplied at the proper time */
          std::deque< signed_transaction >       _popped_tx;
@@ -394,6 +400,12 @@ namespace graphene { namespace chain {
          /**
           * @}
           */
+
+         //////////////////// db_license.cpp ////////////////////
+         void create_license_type(const string& name, const share_type amount, const uint8_t upgrades,
+                                  const uint32_t flags);
+
+
    protected:
          //Mark pop_undo() as protected -- we do not want outside calling pop_undo(); it should call pop_block() instead
          void pop_undo() { object_database::pop_undo(); }
@@ -435,6 +447,8 @@ namespace graphene { namespace chain {
          void update_maintenance_flag( bool new_maintenance_flag );
          void update_withdraw_permissions();
          bool check_for_blackswan( const asset_object& mia, bool enable_black_swan = true );
+         void assign_licenses();
+         void deny_license_request(const license_request_object& req);
 
          ///Steps performed only at maintenance intervals
          ///@{
@@ -447,10 +461,11 @@ namespace graphene { namespace chain {
          void perform_chain_maintenance(const signed_block& next_block, const global_property_object& global_props);
          void update_active_witnesses();
          void update_active_committee_members();
+         void upgrade_cycles();
          void update_worker_votes();
 
-         template<class... Types>
-         void perform_account_maintenance(std::tuple<Types...> helpers);
+         template<typename IndexType, typename IndexBy, class... HelperTypes>
+         void perform_helpers(std::tuple<HelperTypes...> helpers);
          ///@}
          ///@}
 
diff --git a/libraries/chain/include/graphene/chain/genesis_state.hpp b/libraries/chain/include/graphene/chain/genesis_state.hpp
index df87d17..e075a0f 100644
--- a/libraries/chain/include/graphene/chain/genesis_state.hpp
+++ b/libraries/chain/include/graphene/chain/genesis_state.hpp
@@ -98,6 +98,10 @@ struct genesis_state_type {
       string owner_name;
       share_type daily_pay;
    };
+   struct initial_chain_authority_type {
+     /// Must correspond to one of the initial accounts
+     string owner_name;
+   };
 
    time_point_sec                           initial_timestamp;
    share_type                               max_core_supply = GRAPHENE_MAX_SHARE_SUPPLY;
@@ -113,9 +117,15 @@ struct genesis_state_type {
    vector<initial_worker_type>              initial_worker_candidates;
 
    /**
+    * Initial chain authorities.
+    */
+   initial_chain_authority_type             initial_license_issuing_authority;
+   initial_chain_authority_type             initial_license_authentication_authority;
+
+   /**
     * Temporary, will be moved elsewhere.
     */
-   chain_id_type                            initial_chain_id;
+   chain_id_type                          initial_chain_id;
 
    /**
     * Get the chain_id corresponding to this genesis state.
@@ -127,29 +137,77 @@ struct genesis_state_type {
 
 } } // namespace graphene::chain
 
-FC_REFLECT(graphene::chain::genesis_state_type::initial_account_type, (name)(owner_key)(active_key)(is_lifetime_member))
-
-FC_REFLECT(graphene::chain::genesis_state_type::initial_asset_type,
-           (symbol)(issuer_name)(description)(precision)(max_supply)(accumulated_fees)(is_bitasset)(collateral_records))
-
-FC_REFLECT(graphene::chain::genesis_state_type::initial_asset_type::initial_collateral_position,
-           (owner)(collateral)(debt))
-
-FC_REFLECT(graphene::chain::genesis_state_type::initial_balance_type,
-           (owner)(asset_symbol)(amount))
-
-FC_REFLECT(graphene::chain::genesis_state_type::initial_vesting_balance_type,
-           (owner)(asset_symbol)(amount)(begin_timestamp)(vesting_duration_seconds)(begin_balance))
-
-FC_REFLECT(graphene::chain::genesis_state_type::initial_witness_type, (owner_name)(block_signing_key))
-
-FC_REFLECT(graphene::chain::genesis_state_type::initial_committee_member_type, (owner_name))
-
-FC_REFLECT(graphene::chain::genesis_state_type::initial_worker_type, (owner_name)(daily_pay))
-
-FC_REFLECT(graphene::chain::genesis_state_type,
-           (initial_timestamp)(max_core_supply)(initial_parameters)(initial_accounts)(initial_assets)(initial_balances)
-           (initial_vesting_balances)(initial_active_witnesses)(initial_witness_candidates)
-           (initial_committee_candidates)(initial_worker_candidates)
-           (initial_chain_id)
-           (immutable_parameters))
+FC_REFLECT( graphene::chain::genesis_state_type::initial_account_type,
+            (name)
+            (owner_key)
+            (active_key)
+            (is_lifetime_member)
+          )
+
+FC_REFLECT( graphene::chain::genesis_state_type::initial_asset_type,
+            (symbol)
+            (issuer_name)
+            (description)
+            (precision)
+            (max_supply)
+            (accumulated_fees)
+            (is_bitasset)
+            (collateral_records)
+          )
+
+FC_REFLECT( graphene::chain::genesis_state_type::initial_asset_type::initial_collateral_position,
+            (owner)
+            (collateral)
+            (debt)
+          )
+
+FC_REFLECT( graphene::chain::genesis_state_type::initial_balance_type,
+            (owner)
+            (asset_symbol)
+            (amount)
+          )
+
+FC_REFLECT( graphene::chain::genesis_state_type::initial_vesting_balance_type,
+            (owner)
+            (asset_symbol)
+            (amount)
+            (begin_timestamp)
+            (vesting_duration_seconds)
+            (begin_balance)
+          )
+
+FC_REFLECT( graphene::chain::genesis_state_type::initial_witness_type,
+            (owner_name)
+            (block_signing_key)
+          )
+
+FC_REFLECT( graphene::chain::genesis_state_type::initial_committee_member_type,
+            (owner_name)
+          )
+
+FC_REFLECT( graphene::chain::genesis_state_type::initial_worker_type,
+            (owner_name)
+            (daily_pay)
+          )
+
+FC_REFLECT( graphene::chain::genesis_state_type::initial_chain_authority_type,
+            (owner_name)
+          )
+
+FC_REFLECT( graphene::chain::genesis_state_type,
+            (initial_timestamp)
+            (max_core_supply)
+            (initial_parameters)
+            (initial_accounts)
+            (initial_assets)
+            (initial_balances)
+            (initial_vesting_balances)
+            (initial_active_witnesses)
+            (initial_witness_candidates)
+            (initial_committee_candidates)
+            (initial_worker_candidates)
+            (initial_license_issuing_authority)
+            (initial_license_authentication_authority)
+            (initial_chain_id)
+            (immutable_parameters)
+          )
diff --git a/libraries/chain/include/graphene/chain/global_property_object.hpp b/libraries/chain/include/graphene/chain/global_property_object.hpp
index 2c5a1f1..a11c8ff 100644
--- a/libraries/chain/include/graphene/chain/global_property_object.hpp
+++ b/libraries/chain/include/graphene/chain/global_property_object.hpp
@@ -25,6 +25,7 @@
 #include <fc/uint128.hpp>
 
 #include <graphene/chain/protocol/chain_parameters.hpp>
+#include <graphene/chain/protocol/chain_authorities.hpp>
 #include <graphene/chain/protocol/types.hpp>
 #include <graphene/chain/database.hpp>
 #include <graphene/db/object.hpp>
@@ -48,6 +49,8 @@ namespace graphene { namespace chain {
          chain_parameters           parameters;
          optional<chain_parameters> pending_parameters;
 
+         chain_authorities          authorities;
+
          uint32_t                           next_available_vote_id = 0;
          vector<committee_member_id_type>   active_committee_members; // updated once per maintenance interval
          flat_set<witness_id_type>          active_witnesses; // updated once per maintenance interval
@@ -101,6 +104,11 @@ namespace graphene { namespace chain {
          fc::uint128_t recent_slots_filled;
 
          /**
+          * The current global frequency:
+          */
+         float frequency = 0.0;
+
+         /**
           * dynamic_flags specifies chain state properties that can be
           * expressed in one bit.
           */
@@ -108,6 +116,11 @@ namespace graphene { namespace chain {
 
          uint32_t last_irreversible_block_num = 0;
 
+         /**
+          * The number of intervals untill the next cycle upgrade. Set to -1 to avoid upgrading at chain startup.
+          */
+         int intervals_until_cycle_upgrade = -1;
+
          enum dynamic_flag_bits
          {
             /**
@@ -136,8 +149,10 @@ FC_REFLECT_DERIVED( graphene::chain::dynamic_global_property_object, (graphene::
                     (recently_missed_count)
                     (current_aslot)
                     (recent_slots_filled)
+                    (frequency)
                     (dynamic_flags)
                     (last_irreversible_block_num)
+                    (intervals_until_cycle_upgrade)
                   )
 
 FC_REFLECT_DERIVED( graphene::chain::global_property_object, (graphene::db::object),
@@ -145,5 +160,6 @@ FC_REFLECT_DERIVED( graphene::chain::global_property_object, (graphene::db::obje
                     (pending_parameters)
                     (next_available_vote_id)
                     (active_committee_members)
+                    (authorities)
                     (active_witnesses)
                   )
diff --git a/libraries/chain/include/graphene/chain/protocol/chain_parameters.hpp b/libraries/chain/include/graphene/chain/protocol/chain_parameters.hpp
index 4dbd6c1..3782347 100644
--- a/libraries/chain/include/graphene/chain/protocol/chain_parameters.hpp
+++ b/libraries/chain/include/graphene/chain/protocol/chain_parameters.hpp
@@ -36,7 +36,7 @@ namespace fc {
 
 namespace graphene { namespace chain {
 
-   typedef static_variant<>  parameter_extension; 
+   typedef static_variant<>  parameter_extension;
    struct chain_parameters
    {
       /** using a smart ref breaks the circular dependency created between operations and the fee schedule */
@@ -69,6 +69,7 @@ namespace graphene { namespace chain {
       uint16_t                accounts_per_fee_scale              = GRAPHENE_DEFAULT_ACCOUNTS_PER_FEE_SCALE; ///< number of accounts between fee scalings
       uint8_t                 account_fee_scale_bitshifts         = GRAPHENE_DEFAULT_ACCOUNT_FEE_SCALE_BITSHIFTS; ///< number of times to left bitshift account registration fee at each scaling
       uint8_t                 max_authority_depth                 = GRAPHENE_MAX_SIG_CHECK_DEPTH;
+      uint16_t                cycle_upgrade_maintenance_int_count = GRAPHENE_DEFAULT_CYCLE_UPGRADE_MAINT_INT_COUNT;
       extensions_type         extensions;
 
       /** defined in fee_schedule.cpp */
@@ -106,5 +107,6 @@ FC_REFLECT( graphene::chain::chain_parameters,
             (accounts_per_fee_scale)
             (account_fee_scale_bitshifts)
             (max_authority_depth)
+            (cycle_upgrade_maintenance_int_count)
             (extensions)
           )
diff --git a/libraries/chain/include/graphene/chain/protocol/committee_member.hpp b/libraries/chain/include/graphene/chain/protocol/committee_member.hpp
index 7718836..217e910 100644
--- a/libraries/chain/include/graphene/chain/protocol/committee_member.hpp
+++ b/libraries/chain/include/graphene/chain/protocol/committee_member.hpp
@@ -91,16 +91,107 @@ namespace graphene { namespace chain {
       void            validate()const;
    };
 
+
+    /**
+     * @brief Used by committee_members to update the license issuing authority on the blockchain.
+     * @ingroup operations
+     *
+     * This operation allows the committee_members to update the license issuing authority in the global_properties
+     * object on the blockhain. This authority has the power to create licenses, to issue license grant requests to
+     * users. It is checked by the license authorization authority.
+     *
+     * This operation may only be used in a proposed transaction, and a proposed transaction which contains this
+     * operation must have a review period specified in the current global parameters before it may be accepted.
+     */
+    struct committee_member_update_license_issuer_operation : public base_operation
+    {
+      struct fee_parameters_type { uint64_t fee = GRAPHENE_BLOCKCHAIN_PRECISION; };  // TODO: zero the fee?
+
+      asset fee;
+      /// The account to propose:
+      account_id_type license_issuer;
+      /// The commitee member that is proposing the change:
+      account_id_type committee_member_account;
+
+      account_id_type fee_payer()const { return committee_member_account; }
+      void            validate()const;
+    };
+
+    /**
+     * @brief Used by committee_members to update the license authentication authority on the blockchain.
+     * @ingroup operations
+     *
+     * This operation allows the committee_members to update the license authentication authority in the
+     * global_properties object on the blockhain. This authority has the verify and confirm license requests that the
+     * license issuing authority has issued to an user.
+     *
+     * This operation may only be used in a proposed transaction, and a proposed transaction which contains this
+     * operation must have a review period specified in the current global parameters before it may be accepted.
+     */
+    struct committee_member_update_license_authenticator_operation : public base_operation
+    {
+      struct fee_parameters_type { uint64_t fee = GRAPHENE_BLOCKCHAIN_PRECISION; };  // TODO: zero the fee?
+
+      asset fee;
+      /// The account to propose:
+      account_id_type license_authenticator;
+      /// The commitee member that is proposing the change:
+      account_id_type committee_member_account;
+
+      account_id_type fee_payer()const { return committee_member_account; }
+      void            validate()const;
+    };
+
    /// TODO: committee_member_resign_operation : public base_operation
 
 } } // graphene::chain
-FC_REFLECT( graphene::chain::committee_member_create_operation::fee_parameters_type, (fee) )
-FC_REFLECT( graphene::chain::committee_member_update_operation::fee_parameters_type, (fee) )
-FC_REFLECT( graphene::chain::committee_member_update_global_parameters_operation::fee_parameters_type, (fee) )
 
+FC_REFLECT( graphene::chain::committee_member_create_operation::fee_parameters_type,
+            (fee)
+          )
+
+FC_REFLECT( graphene::chain::committee_member_update_operation::fee_parameters_type,
+            (fee)
+          )
+
+FC_REFLECT( graphene::chain::committee_member_update_global_parameters_operation::fee_parameters_type,
+            (fee)
+          )
+
+FC_REFLECT( graphene::chain::committee_member_update_license_issuer_operation::fee_parameters_type,
+            (fee)
+          )
+
+FC_REFLECT( graphene::chain::committee_member_update_license_authenticator_operation::fee_parameters_type,
+            (fee)
+          )
 
 FC_REFLECT( graphene::chain::committee_member_create_operation,
-            (fee)(committee_member_account)(url) )
+            (fee)
+            (committee_member_account)
+            (url)
+          )
+
 FC_REFLECT( graphene::chain::committee_member_update_operation,
-            (fee)(committee_member)(committee_member_account)(new_url) )
-FC_REFLECT( graphene::chain::committee_member_update_global_parameters_operation, (fee)(new_parameters) );
+            (fee)
+            (committee_member)
+            (committee_member_account)
+            (new_url)
+          )
+
+FC_REFLECT( graphene::chain::committee_member_update_global_parameters_operation,
+            (fee)
+            (new_parameters)
+          );
+
+FC_REFLECT( graphene::chain::committee_member_update_license_issuer_operation,
+            (fee)
+            (license_issuer)
+            (committee_member_account)
+          );
+
+FC_REFLECT( graphene::chain::committee_member_update_license_authenticator_operation,
+            (fee)
+            (license_authenticator)
+            (committee_member_account)
+          );
\ No newline at end of file
diff --git a/libraries/chain/include/graphene/chain/protocol/operations.hpp b/libraries/chain/include/graphene/chain/protocol/operations.hpp
index 7f2639f..174693a 100644
--- a/libraries/chain/include/graphene/chain/protocol/operations.hpp
+++ b/libraries/chain/include/graphene/chain/protocol/operations.hpp
@@ -31,6 +31,7 @@
 #include <graphene/chain/protocol/committee_member.hpp>
 #include <graphene/chain/protocol/confidential.hpp>
 #include <graphene/chain/protocol/fba.hpp>
+#include <graphene/chain/protocol/license.hpp>
 #include <graphene/chain/protocol/market.hpp>
 #include <graphene/chain/protocol/proposal.hpp>
 #include <graphene/chain/protocol/transfer.hpp>
@@ -91,18 +92,26 @@ namespace graphene { namespace chain {
             transfer_from_blind_operation,
             asset_settle_cancel_operation,  // VIRTUAL
             asset_claim_fees_operation,
-            fba_distribute_operation        // VIRTUAL
+            fba_distribute_operation,        // VIRTUAL
+            committee_member_update_license_issuer_operation,
+            committee_member_update_license_authenticator_operation,
+            license_type_create_operation,
+            license_type_edit_operation,
+            license_type_delete_operation,
+            license_request_operation,
+            license_approve_operation,
+            license_deny_operation
          > operation;
 
    /// @} // operations group
 
    /**
     *  Appends required authorites to the result vector.  The authorities appended are not the
-    *  same as those returned by get_required_auth 
+    *  same as those returned by get_required_auth
     *
     *  @return a set of required authorities for @ref op
     */
-   void operation_get_required_authorities( const operation& op, 
+   void operation_get_required_authorities( const operation& op,
                                             flat_set<account_id_type>& active,
                                             flat_set<account_id_type>& owner,
                                             vector<authority>&  other );
@@ -122,4 +131,7 @@ namespace graphene { namespace chain {
 } } // graphene::chain
 
 FC_REFLECT_TYPENAME( graphene::chain::operation )
-FC_REFLECT( graphene::chain::op_wrapper, (op) )
+
+FC_REFLECT( graphene::chain::op_wrapper,
+            (op)
+          )
diff --git a/libraries/chain/include/graphene/chain/protocol/types.hpp b/libraries/chain/include/graphene/chain/protocol/types.hpp
index 5237fca..711180f 100644
--- a/libraries/chain/include/graphene/chain/protocol/types.hpp
+++ b/libraries/chain/include/graphene/chain/protocol/types.hpp
@@ -107,6 +107,14 @@ namespace graphene { namespace chain {
       implementation_ids    = 2
    };
 
+   enum cycle_policy_flags
+   {
+      auto_submit_to_queue    = 0x01,  /**< are cycles automatically submitted to the queue? */
+      retain_after_submission = 0x02,  /**< after submission, do we spend the cycles*/
+   };
+   const static uint32_t CYCLE_POLICY_AUTO_SUBMIT_MASK = auto_submit_to_queue;
+   const static uint32_t CYCLE_POLICY_CHARTER_MASK = auto_submit_to_queue | retain_after_submission;
+
    inline bool is_relative( object_id_type o ){ return o.space() == 0; }
 
    /**
@@ -155,7 +163,10 @@ namespace graphene { namespace chain {
       impl_budget_record_object_type,
       impl_special_authority_object_type,
       impl_buyback_object_type,
-      impl_fba_accumulator_object_type
+      impl_fba_accumulator_object_type,
+      impl_license_type_object_type,
+      impl_license_request_object_type,
+      impl_account_cycle_balance_object_type
    };
 
    //typedef fc::unsigned_int            object_id_type;
@@ -207,6 +218,9 @@ namespace graphene { namespace chain {
    class special_authority_object;
    class buyback_object;
    class fba_accumulator_object;
+   class license_type_object;
+   class license_request_object;
+   class account_cycle_balance_object;
 
    typedef object_id< implementation_ids, impl_global_property_object_type,  global_property_object>                    global_property_id_type;
    typedef object_id< implementation_ids, impl_dynamic_global_property_object_type,  dynamic_global_property_object>    dynamic_global_property_id_type;
@@ -228,6 +242,19 @@ namespace graphene { namespace chain {
    typedef object_id< implementation_ids, impl_buyback_object_type, buyback_object >                                    buyback_id_type;
    typedef object_id< implementation_ids, impl_fba_accumulator_object_type, fba_accumulator_object >                    fba_accumulator_id_type;
 
+   typedef object_id<
+      implementation_ids, impl_license_type_object_type, license_type_object
+   > license_type_id_type;
+
+   typedef object_id<
+      implementation_ids, impl_license_request_object_type, license_request_object
+   > license_request_id_type;
+
+   typedef object_id<
+    implementation_ids, impl_account_cycle_balance_object_type, account_cycle_balance_object
+   > account_cycle_balance_id_type;
+
+
    typedef fc::array<char, GRAPHENE_MAX_ASSET_SYMBOL_LENGTH>    symbol_type;
    typedef fc::ripemd160                                        block_id_type;
    typedef fc::ripemd160                                        checksum_type;
@@ -236,6 +263,7 @@ namespace graphene { namespace chain {
    typedef fc::ecc::compact_signature                           signature_type;
    typedef safe<int64_t>                                        share_type;
    typedef uint16_t                                             weight_type;
+   typedef float                                                frequency_type;
 
    struct public_key_type
    {
@@ -268,9 +296,9 @@ namespace graphene { namespace chain {
          uint32_t                   check = 0;
          fc::ecc::extended_key_data data;
       };
-      
+
       fc::ecc::extended_key_data key_data;
-       
+
       extended_public_key_type();
       extended_public_key_type( const fc::ecc::extended_key_data& data );
       extended_public_key_type( const fc::ecc::extended_public_key& extpubkey );
@@ -281,7 +309,7 @@ namespace graphene { namespace chain {
       friend bool operator == ( const extended_public_key_type& p1, const extended_public_key_type& p2);
       friend bool operator != ( const extended_public_key_type& p1, const extended_public_key_type& p2);
    };
-   
+
    struct extended_private_key_type
    {
       struct binary_key
@@ -290,9 +318,9 @@ namespace graphene { namespace chain {
          uint32_t                   check = 0;
          fc::ecc::extended_key_data data;
       };
-      
+
       fc::ecc::extended_key_data key_data;
-       
+
       extended_private_key_type();
       extended_private_key_type( const fc::ecc::extended_key_data& data );
       extended_private_key_type( const fc::ecc::extended_private_key& extprivkey );
@@ -359,6 +387,9 @@ FC_REFLECT_ENUM( graphene::chain::impl_object_type,
                  (impl_special_authority_object_type)
                  (impl_buyback_object_type)
                  (impl_fba_accumulator_object_type)
+                 (impl_license_type_object_type)
+                 (impl_license_request_object_type)
+                 (impl_account_cycle_balance_object_type)
                )
 
 FC_REFLECT_TYPENAME( graphene::chain::share_type )
@@ -390,6 +421,9 @@ FC_REFLECT_TYPENAME( graphene::chain::budget_record_id_type )
 FC_REFLECT_TYPENAME( graphene::chain::special_authority_id_type )
 FC_REFLECT_TYPENAME( graphene::chain::buyback_id_type )
 FC_REFLECT_TYPENAME( graphene::chain::fba_accumulator_id_type )
+FC_REFLECT_TYPENAME( graphene::chain::license_type_id_type )
+FC_REFLECT_TYPENAME( graphene::chain::license_request_id_type )
+FC_REFLECT_TYPENAME( graphene::chain::account_cycle_balance_id_type )
 
 FC_REFLECT( graphene::chain::void_t, )
 
@@ -404,3 +438,8 @@ FC_REFLECT_ENUM( graphene::chain::asset_issuer_permission_flags,
    (witness_fed_asset)
    (committee_fed_asset)
    )
+
+FC_REFLECT_ENUM( graphene::chain::cycle_policy_flags,
+                 (auto_submit_to_queue)
+                 (retain_after_submission)
+               )
diff --git a/libraries/chain/protocol/committee_member.cpp b/libraries/chain/protocol/committee_member.cpp
index 4c8c5d2..d8b947f 100644
--- a/libraries/chain/protocol/committee_member.cpp
+++ b/libraries/chain/protocol/committee_member.cpp
@@ -44,4 +44,14 @@ void committee_member_update_global_parameters_operation::validate() const
    new_parameters.validate();
 }
 
+void committee_member_update_license_issuer_operation::validate() const
+{
+	FC_ASSERT( fee.amount >= 0 );
+}
+
+void committee_member_update_license_authenticator_operation::validate() const
+{
+	FC_ASSERT( fee.amount >= 0 );
+}
+
 } } // graphene::chain
diff --git a/libraries/wallet/include/graphene/wallet/reflect_util.hpp b/libraries/wallet/include/graphene/wallet/reflect_util.hpp
index 497303c..9a9feea 100644
--- a/libraries/wallet/include/graphene/wallet/reflect_util.hpp
+++ b/libraries/wallet/include/graphene/wallet/reflect_util.hpp
@@ -69,7 +69,7 @@ struct static_variant_map_visitor
    }
 
    static_variant_map m;
-   int which;
+   uint32_t which;
 };
 
 template< typename StaticVariant >
diff --git a/libraries/wallet/include/graphene/wallet/wallet.hpp b/libraries/wallet/include/graphene/wallet/wallet.hpp
index b171d5c..93846b9 100644
--- a/libraries/wallet/include/graphene/wallet/wallet.hpp
+++ b/libraries/wallet/include/graphene/wallet/wallet.hpp
@@ -67,7 +67,7 @@ struct brain_key_info
  *  the meta data about the receipt that helps the sender identify which receipt is
  *  for the receiver and which is for the change address.
  */
-struct blind_confirmation 
+struct blind_confirmation
 {
    struct output
    {
@@ -287,7 +287,7 @@ class wallet_api
        */
       uint64_t                          get_account_count()const;
       /** Lists all accounts controlled by this wallet.
-       * This returns a list of the full account objects for all accounts whose private keys 
+       * This returns a list of the full account objects for all accounts whose private keys
        * we possess.
        * @returns a list of account objects
        */
@@ -299,14 +299,14 @@ class wallet_api
        * start by setting \c lowerbound to the empty string \c "", and then each iteration, pass
        * the last account name returned as the \c lowerbound for the next \c list_accounts() call.
        *
-       * @param lowerbound the name of the first account to return.  If the named account does not exist, 
+       * @param lowerbound the name of the first account to return.  If the named account does not exist,
        *                   the list will start at the account that comes after \c lowerbound
        * @param limit the maximum number of accounts to return (max: 1000)
        * @returns a list of accounts mapping account names to account ids
        */
       map<string,account_id_type>       list_accounts(const string& lowerbound, uint32_t limit);
       /** List the balances of an account.
-       * Each account can have multiple balances, one for each type of asset owned by that 
+       * Each account can have multiple balances, one for each type of asset owned by that
        * account.  The returned list will only contain assets for which the account has a
        * nonzero balance
        * @param id the name or id of the account whose balances you want
@@ -314,7 +314,7 @@ class wallet_api
        */
       vector<asset>                     list_account_balances(const string& id);
       /** Lists all assets registered on the blockchain.
-       * 
+       *
        * To list all assets, pass the empty string \c "" for the lowerbound to start
        * at the beginning of the list, and iterate as necessary.
        *
@@ -323,7 +323,6 @@ class wallet_api
        * @returns the list of asset objects, ordered by symbol
        */
       vector<asset_object>              list_assets(const string& lowerbound, uint32_t limit)const;
-      
       /** Returns the most recent operations on the named account.
        *
        * This returns a list of operation history objects, which describe activity on the account.
@@ -341,7 +340,7 @@ class wallet_api
       vector<limit_order_object>        get_limit_orders(string a, string b, uint32_t limit)const;
       vector<call_order_object>         get_call_orders(string a, uint32_t limit)const;
       vector<force_settlement_object>   get_settle_orders(string a, uint32_t limit)const;
-      
+
       /** Returns the block chain's slowly-changing settings.
        * This object contains all of the properties of the blockchain that are fixed
        * or that change only once per maintenance interval (daily) such as the
@@ -397,8 +396,8 @@ class wallet_api
        * Returns the blockchain object corresponding to the given id.
        *
        * This generic function can be used to retrieve any object from the blockchain
-       * that is assigned an ID.  Certain types of objects have specialized convenience 
-       * functions to return their objects -- e.g., assets have \c get_asset(), accounts 
+       * that is assigned an ID.  Certain types of objects have specialized convenience
+       * functions to return their objects -- e.g., assets have \c get_asset(), accounts
        * have \c get_account(), but this function will work for any object.
        *
        * @param id the id of the object to return
@@ -406,7 +405,7 @@ class wallet_api
        */
       variant                           get_object(object_id_type id) const;
 
-      /** Returns the current wallet filename.  
+      /** Returns the current wallet filename.
        *
        * This is the filename that will be used when automatically saving the wallet.
        *
@@ -477,21 +476,21 @@ class wallet_api
        * @ingroup Wallet Management
        */
       bool    is_new()const;
-      
-      /** Checks whether the wallet is locked (is unable to use its private keys).  
+
+      /** Checks whether the wallet is locked (is unable to use its private keys).
        *
        * This state can be changed by calling \c lock() or \c unlock().
        * @return true if the wallet is locked
        * @ingroup Wallet Management
        */
       bool    is_locked()const;
-      
+
       /** Locks the wallet immediately.
        * @ingroup Wallet Management
        */
       void    lock();
-      
-      /** Unlocks the wallet.  
+
+      /** Unlocks the wallet.
        *
        * The wallet remain unlocked until the \c lock is called
        * or the program exits.
@@ -499,7 +498,7 @@ class wallet_api
        * @ingroup Wallet Management
        */
       void    unlock(string password);
-      
+
       /** Sets a new password on the wallet.
        *
        * The wallet must be either 'new' or 'unlocked' to
@@ -512,7 +511,7 @@ class wallet_api
        *
        * The keys are printed in WIF format.  You can import these keys into another wallet
        * using \c import_key()
-       * @returns a map containing the private keys, indexed by their public key 
+       * @returns a map containing the private keys, indexed by their public key
        */
       map<public_key_type, string> dump_private_keys();
 
@@ -547,7 +546,7 @@ class wallet_api
       bool    load_wallet_file(string wallet_filename = "");
 
       /** Saves the current wallet to the given filename.
-       * 
+       *
        * @warning This does not change the wallet filename that will be used for future
        * writes, so think of this function as 'Save a Copy As...' instead of
        * 'Save As...'.  Use \c set_wallet_filename() to make the filename
@@ -581,8 +580,8 @@ class wallet_api
        * TODO: I don't see a broadcast_transaction() function, do we need one?
        *
        * @param tx the transaction to serialize
-       * @returns the binary form of the transaction.  It will not be hex encoded, 
-       *          this returns a raw string that may have null characters embedded 
+       * @returns the binary form of the transaction.  It will not be hex encoded,
+       *          this returns a raw string that may have null characters embedded
        *          in it
        */
       string serialize_transaction(signed_transaction tx) const;
@@ -590,7 +589,7 @@ class wallet_api
       /** Imports the private key for an existing account.
        *
        * The private key must match either an owner key or an active key for the
-       * named account.  
+       * named account.
        *
        * @see dump_private_keys()
        *
@@ -693,7 +692,7 @@ class wallet_api
        * @param to the name or id of the account receiving the funds
        * @param amount the amount to send (in nominal units -- to send half of a BTS, specify 0.5)
        * @param asset_symbol the symbol or id of the asset to send
-       * @param memo a memo to attach to the transaction.  The memo will be encrypted in the 
+       * @param memo a memo to attach to the transaction.  The memo will be encrypted in the
        *             transaction and readable for the receiver.  There is no length limit
        *             other than the limit imposed by maximum transaction size, but transaction
        *             increase with transaction size
@@ -768,7 +767,7 @@ class wallet_api
        *  who sent it.
        *
        *  @param opt_from - if not empty and the sender is a unknown public key, then the unknown public key will be given the label opt_from
-       *  @param confirmation_receipt - a base58 encoded stealth confirmation 
+       *  @param confirmation_receipt - a base58 encoded stealth confirmation
        */
       blind_receipt receive_blind_transfer( string confirmation_receipt, string opt_from, string opt_memo );
 
@@ -776,18 +775,18 @@ class wallet_api
        *  Transfers a public balance from @from to one or more blinded balances using a
        *  stealth transfer.
        */
-      blind_confirmation transfer_to_blind( string from_account_id_or_name, 
+      blind_confirmation transfer_to_blind( string from_account_id_or_name,
                                             string asset_symbol,
                                             /** map from key or label to amount */
-                                            vector<pair<string, string>> to_amounts, 
+                                            vector<pair<string, string>> to_amounts,
                                             bool broadcast = false );
 
       /**
        * Transfers funds from a set of blinded balances to a public account balance.
        */
-      blind_confirmation transfer_from_blind( 
+      blind_confirmation transfer_from_blind(
                                             string from_blind_account_key_or_label,
-                                            string to_account_id_or_name, 
+                                            string to_account_id_or_name,
                                             string amount,
                                             string asset_symbol,
                                             bool broadcast = false );
@@ -803,14 +802,14 @@ class wallet_api
 
       /** Place a limit order attempting to sell one asset for another.
        *
-       * Buying and selling are the same operation on Graphene; if you want to buy BTS 
+       * Buying and selling are the same operation on Graphene; if you want to buy BTS
        * with USD, you should sell USD for BTS.
        *
        * The blockchain will attempt to sell the \c symbol_to_sell for as
-       * much \c symbol_to_receive as possible, as long as the price is at 
-       * least \c min_to_receive / \c amount_to_sell.   
+       * much \c symbol_to_receive as possible, as long as the price is at
+       * least \c min_to_receive / \c amount_to_sell.
        *
-       * In addition to the transaction fees, market fees will apply as specified 
+       * In addition to the transaction fees, market fees will apply as specified
        * by the issuer of both the selling asset and the receiving asset as
        * a percentage of the amount exchanged.
        *
@@ -823,16 +822,16 @@ class wallet_api
        *
        * @todo Allow order expiration to be set here.  Document default/max expiration time
        *
-       * @param seller_account the account providing the asset being sold, and which will 
+       * @param seller_account the account providing the asset being sold, and which will
        *                       receive the proceeds of the sale.
        * @param amount_to_sell the amount of the asset being sold to sell (in nominal units)
        * @param symbol_to_sell the name or id of the asset to sell
        * @param min_to_receive the minimum amount you are willing to receive in return for
        *                       selling the entire amount_to_sell
        * @param symbol_to_receive the name or id of the asset you wish to receive
-       * @param timeout_sec if the order does not fill immediately, this is the length of 
-       *                    time the order will remain on the order books before it is 
-       *                    cancelled and the un-spent funds are returned to the seller's 
+       * @param timeout_sec if the order does not fill immediately, this is the length of
+       *                    time the order will remain on the order books before it is
+       *                    cancelled and the un-spent funds are returned to the seller's
        *                    account
        * @param fill_or_kill if true, the order will only be included in the blockchain
        *                     if it is filled immediately; if false, an open order will be
@@ -849,12 +848,12 @@ class wallet_api
                                     uint32_t timeout_sec = 0,
                                     bool     fill_or_kill = false,
                                     bool     broadcast = false);
-                                    
+
       /** Place a limit order attempting to sell one asset for another.
-       * 
+       *
        * This API call abstracts away some of the details of the sell_asset call to be more
        * user friendly. All orders placed with sell never timeout and will not be killed if they
-       * cannot be filled immediately. If you wish for one of these parameters to be different, 
+       * cannot be filled immediately. If you wish for one of these parameters to be different,
        * then sell_asset should be used instead.
        *
        * @param seller_account the account providing the asset being sold, and which will
@@ -864,7 +863,7 @@ class wallet_api
        * @param rate The rate in base:quote at which you want to sell.
        * @param amount The amount of base you want to sell.
        * @param broadcast true to broadcast the transaction on the network.
-       * @returns The signed transaction selling the funds.                 
+       * @returns The signed transaction selling the funds.
        */
       signed_transaction sell( string seller_account,
                                string base,
@@ -872,7 +871,7 @@ class wallet_api
                                double rate,
                                double amount,
                                bool broadcast );
-                               
+
       /** Place a limit order attempting to buy one asset with another.
        *
        * This API call abstracts away some of the details of the sell_asset call to be more
@@ -927,14 +926,14 @@ class wallet_api
        * Right now this function is difficult to use because you must provide raw JSON data
        * structures for the options objects, and those include prices and asset ids.
        *
-       * @param issuer the name or id of the account who will pay the fee and become the 
+       * @param issuer the name or id of the account who will pay the fee and become the
        *               issuer of the new asset.  This can be updated later
        * @param symbol the ticker symbol of the new asset
        * @param precision the number of digits of precision to the right of the decimal point,
        *                  must be less than or equal to 12
        * @param common asset options required for all new assets.
-       *               Note that core_exchange_rate technically needs to store the asset ID of 
-       *               this new asset. Since this ID is not known at the time this operation is 
+       *               Note that core_exchange_rate technically needs to store the asset ID of
+       *               this new asset. Since this ID is not known at the time this operation is
        *               created, create this price as though the new asset has instance ID 1, and
        *               the chain will overwrite it with the new asset's ID.
        * @param bitasset_opts options specific to BitAssets.  This may be null unless the
@@ -964,8 +963,8 @@ class wallet_api
                                      bool broadcast = false);
 
       /** Update the core options on an asset.
-       * There are a number of options which all assets in the network use. These options are 
-       * enumerated in the asset_object::asset_options struct. This command is used to update 
+       * There are a number of options which all assets in the network use. These options are
+       * enumerated in the asset_object::asset_options struct. This command is used to update
        * these options for an existing asset.
        *
        * @note This operation cannot be used to update BitAsset-specific options. For these options,
@@ -1014,7 +1013,7 @@ class wallet_api
       signed_transaction update_asset_feed_producers(string symbol,
                                                      flat_set<string> new_feed_producers,
                                                      bool broadcast = false);
-      
+
       /** Publishes a price feed for the named asset.
        *
        * Price feed providers use this command to publish their price feeds for market-issued assets. A price feed is
@@ -1042,7 +1041,7 @@ class wallet_api
 
       /** Pay into the fee pool for the given asset.
        *
-       * User-issued assets can optionally have a pool of the core asset which is 
+       * User-issued assets can optionally have a pool of the core asset which is
        * automatically used to pay transaction fees for any transaction using that
        * asset (using the asset's core exchange rate).
        *
@@ -1083,7 +1082,7 @@ class wallet_api
        * used as backing for other bitassets, those bitassets will be force settled at their current
        * feed price.
        *
-       * @note this operation is used only by the asset issuer, \c settle_asset() may be used by 
+       * @note this operation is used only by the asset issuer, \c settle_asset() may be used by
        *       any user owning the asset
        *
        * @param symbol the name or id of the asset to force settlement on
@@ -1151,7 +1150,7 @@ class wallet_api
        * @returns the signed transaction registering a committee_member
        */
       signed_transaction create_committee_member(string owner_account,
-                                         string url, 
+                                         string url,
                                          bool broadcast = false);
 
       /** Lists all witnesses registered in the blockchain.
@@ -1162,7 +1161,7 @@ class wallet_api
        * start by setting \c lowerbound to the empty string \c "", and then each iteration, pass
        * the last witness name returned as the \c lowerbound for the next \c list_witnesss() call.
        *
-       * @param lowerbound the name of the first witness to return.  If the named witness does not exist, 
+       * @param lowerbound the name of the first witness to return.  If the named witness does not exist,
        *                   the list will start at the witness that comes after \c lowerbound
        * @param limit the maximum number of witnesss to return (max: 1000)
        * @returns a list of witnesss mapping witness names to witness ids
@@ -1177,7 +1176,7 @@ class wallet_api
        * start by setting \c lowerbound to the empty string \c "", and then each iteration, pass
        * the last committee_member name returned as the \c lowerbound for the next \c list_committee_members() call.
        *
-       * @param lowerbound the name of the first committee_member to return.  If the named committee_member does not exist, 
+       * @param lowerbound the name of the first committee_member to return.  If the named committee_member does not exist,
        *                   the list will start at the committee_member that comes after \c lowerbound
        * @param limit the maximum number of committee_members to return (max: 1000)
        * @returns a list of committee_members mapping committee_member names to committee_member ids
@@ -1283,7 +1282,7 @@ class wallet_api
 
       /** Vote for a given committee_member.
        *
-       * An account can publish a list of all committee_memberes they approve of.  This 
+       * An account can publish a list of all committee_memberes they approve of.  This
        * command allows you to add or remove committee_memberes from this list.
        * Each account's vote is weighted according to the number of shares of the
        * core asset owned by that account at the time the votes are tallied.
@@ -1293,7 +1292,7 @@ class wallet_api
        *
        * @param voting_account the name or id of the account who is voting with their shares
        * @param committee_member the name or id of the committee_member' owner account
-       * @param approve true if you wish to vote in favor of that committee_member, false to 
+       * @param approve true if you wish to vote in favor of that committee_member, false to
        *                remove your vote in favor of that committee_member
        * @param broadcast true if you wish to broadcast the transaction
        * @return the signed transaction changing your vote for the given committee_member
@@ -1305,7 +1304,7 @@ class wallet_api
 
       /** Vote for a given witness.
        *
-       * An account can publish a list of all witnesses they approve of.  This 
+       * An account can publish a list of all witnesses they approve of.  This
        * command allows you to add or remove witnesses from this list.
        * Each account's vote is weighted according to the number of shares of the
        * core asset owned by that account at the time the votes are tallied.
@@ -1315,7 +1314,7 @@ class wallet_api
        *
        * @param voting_account the name or id of the account who is voting with their shares
        * @param witness the name or id of the witness' owner account
-       * @param approve true if you wish to vote in favor of that witness, false to 
+       * @param approve true if you wish to vote in favor of that witness, false to
        *                remove your vote in favor of that witness
        * @param broadcast true if you wish to broadcast the transaction
        * @return the signed transaction changing your vote for the given witness
@@ -1346,23 +1345,23 @@ class wallet_api
       signed_transaction set_voting_proxy(string account_to_modify,
                                           optional<string> voting_account,
                                           bool broadcast = false);
-      
+
       /** Set your vote for the number of witnesses and committee_members in the system.
        *
-       * Each account can voice their opinion on how many committee_members and how many 
+       * Each account can voice their opinion on how many committee_members and how many
        * witnesses there should be in the active committee_member/active witness list.  These
        * are independent of each other.  You must vote your approval of at least as many
        * committee_members or witnesses as you claim there should be (you can't say that there should
-       * be 20 committee_members but only vote for 10). 
+       * be 20 committee_members but only vote for 10).
        *
-       * There are maximum values for each set in the blockchain parameters (currently 
+       * There are maximum values for each set in the blockchain parameters (currently
        * defaulting to 1001).
        *
        * This setting can be changed at any time.  If your account has a voting proxy
        * set, your preferences will be ignored.
        *
        * @param account_to_modify the name or id of the account to update
-       * @param number_of_committee_members the number 
+       * @param number_of_committee_members the number
        *
        * @param broadcast true if you wish to broadcast the transaction
        * @return the signed transaction changing your vote proxy settings
@@ -1384,16 +1383,16 @@ class wallet_api
 
       /** Returns an uninitialized object representing a given blockchain operation.
        *
-       * This returns a default-initialized object of the given type; it can be used 
+       * This returns a default-initialized object of the given type; it can be used
        * during early development of the wallet when we don't yet have custom commands for
-       * creating all of the operations the blockchain supports.  
+       * creating all of the operations the blockchain supports.
        *
        * Any operation the blockchain supports can be created using the transaction builder's
-       * \c add_operation_to_builder_transaction() , but to do that from the CLI you need to 
+       * \c add_operation_to_builder_transaction() , but to do that from the CLI you need to
        * know what the JSON form of the operation looks like.  This will give you a template
        * you can fill in.  It's better than nothing.
-       * 
-       * @param operation_type the type of operation to return, must be one of the 
+       *
+       * @param operation_type the type of operation to return, must be one of the
        *                       operations defined in `graphene/chain/operations.hpp`
        *                       (e.g., "global_parameters_update_operation")
        * @return a default-constructed operation of the given type
@@ -1418,7 +1417,7 @@ class wallet_api
          bool broadcast = false);
 
       /** Propose a fee change.
-       * 
+       *
        * @param proposing_account The account paying the fee to propose the tx
        * @param expiration_time Timestamp specifying when the proposal will either take effect or expire.
        * @param changed_values Map of operation type to new fee.  Operations may be specified by name or ID.
@@ -1446,7 +1445,165 @@ class wallet_api
          const approval_delta& delta,
          bool broadcast /* = false */
          );
-         
+
+      ///////////////////////////////
+      /// LICENSES:               ///
+      ///////////////////////////////
+
+      /**
+       * Create a license type. Only the license authentication authority can do this.
+       *
+       * @param lic_authenticator MUST be the name of the current license authentication authority.
+       * @param name Name of the license.
+       * @param amount Thee amount of cycles the license grants.
+       * @param upgrades Number of cycle upgrades.
+       * @param policy_flags The policy flags for the license, see @ref cycle_policy_flags for more details.
+       *
+       * @return Signed transaction.
+       */
+      signed_transaction create_license_type_with_policy_flags(
+        const string& lic_authenticator,
+        const string& name,
+        share_type amount,
+        uint8_t upgrades,
+        uint32_t policy_flags,
+        bool broadcast /*  = false */
+        );
+
+      /**
+       * Create a standard license type. Only the license authentication authority can do this.
+       * Uses the standard cycle policy.
+       *
+       * @param lic_authenticator MUST be the name of the current license authentication authority.
+       * @param name Name of the license.
+       * @param amount Thee amount of cycles the license grants.
+       * @param upgrades Number of cycle upgrades.
+       * @param broadcast true if you wish to broadcast the transaction.
+       *
+       * @return Signed transaction.
+       */
+      signed_transaction create_license_type_standard(
+        const string& lic_authenticator,
+        const string& name,
+        share_type amount,
+        uint8_t upgrades,
+        bool broadcast /*  = false */
+        );
+
+      /**
+       * Create a chartered license type. Only the license authentication authority can do this.
+       * Uses the chartered cycle policy.
+       *
+       * @param lic_authenticator   MUST be the name of the current license authentication authority.
+       * @param name                Name of the license.
+       * @param amount              The amount of cycles the license grants.
+       * @param upgrades            Number of cycle upgrades.
+       * @param broadcast           true if you wish to broadcast the transaction.
+       *
+       * @return Signed transaction.
+       */
+      signed_transaction create_license_type_chartered(
+        const string& lic_authenticator,
+        const string& name,
+        share_type amount,
+        uint8_t upgrades,
+        bool broadcast /*  = false */
+        );
+
+      /**
+       * Edit an existing license_type. Only the license authentication authority can do this. Note that this operation
+       * is NOT RETROACTIVE!
+       *
+       * @param  lic_authenticator MUST be the license authenticator.
+       * @param  name              New license name.
+       * @param  amount            New amount.
+       * @param  upgrades          New upgrade count.
+       * @param  policy_flags      New policy flags.
+       * @param  broadcast         true if you wish to broadcast the transaction.
+       * @return                   Signed version of the transaction.
+       */
+      signed_transaction edit_license_type(
+        const string& lic_authenticator,
+        const string& name,
+        share_type amount,
+        uint8_t upgrades,
+        uint32_t policy_flags,
+        bool broadcast /* false */
+        );
+
+      /**
+       * Issue a license to an account. This will create a license request object that can be denied by the license
+       * authentication authority.
+       *
+       * @param issuer            This MUST be the license issuing chain authority.
+       * @param account           The account that will benefit the license.
+       * @param license           The id of the license that will be granted to the account.
+       * @param account_frequency Frequency lock for this account.
+       * @param broadcast         true if you wish to broadcast the transaction.
+       * @return                  The signed version of the transaction.
+       */
+      signed_transaction issue_license(
+        const string& issuer,
+        const string& account,
+        const string& license,
+        fc::optional<frequency_type> account_frequency,
+        bool broadcast /* false */
+        );
+
+      /**
+       * Deny a license request. Only the license authentication authority can do this.
+       * @param  authenticator THis MUST be the license authentication authority.
+       * @param  req_id        The id of the request we want to deny.
+       * @param  broadcast     true if you wish to broadcast the transaction.
+       * @return               The signed version of the transaction.
+       */
+      signed_transaction deny_license_request(
+        const string& authenticator,
+        const string& req_id,
+        bool broadcast /* false */
+        );
+
+      /** Lists all license types active on the blockchain, sorted by name.
+       *
+       * To list all license types, pass the empty string \c "" for the lowerbound to start
+       * at the beginning of the list, and iterate as necessary.
+       *
+       * @param lower_bound_name    The name of the first license type to include in the list.
+       * @param limit               The maximum number of license types to return (max: 100).
+       * @return                    List of license type objects, ordered by name.
+       */
+      vector<license_type_object> list_license_types_by_name( const string& lower_bound_name, uint32_t limit )const;
+
+      /** Lists all license types active on the blockchain, sorted by amount.
+       *
+       * To list all license types, pass the empty string \c "" for the lowerbound to start
+       * at the beginning of the list, and iterate as necessary.
+       *
+       * @param lower_bound_name    The name of the first license type to include in the list.
+       * @param limit               The maximum number of license types to return (max: 100).
+       * @return                    List of license type objects, ordered by amount.
+       */
+      vector<license_type_object> list_license_types_by_amount( const uint32_t lower_bound_amount, uint32_t limit )const;
+
+      /**
+       * List all license requests on the blockchain, sorted by expiration.
+       *
+       * @param limit Maximum number of requests to return.
+       * @return The list of request objects, ordered by expiration time.
+       */
+      vector<license_request_object> list_license_requests_by_expiration( uint32_t limit )const;
+
+      ///////////////////////////////
+      /// CYCLES:                 ///
+      ///////////////////////////////
+
+      /**
+       * Get the amount of cycles in the account.
+       * @param  account Account name or stringified id.
+       * @return         Cycle balance of the account.
+       */
+      share_type get_account_cycle_balance( const string& account )const;
+
       order_book get_order_book( const string& base, const string& quote, unsigned limit = 50);
 
       void dbg_make_uia(string creator, string symbol);
@@ -1535,7 +1692,7 @@ FC_REFLECT_DERIVED( graphene::wallet::signed_block_with_info, (graphene::chain::
 FC_REFLECT_DERIVED( graphene::wallet::vesting_balance_object_with_info, (graphene::chain::vesting_balance_object),
    (allowed_withdraw)(allowed_withdraw_time) )
 
-FC_REFLECT( graphene::wallet::operation_detail, 
+FC_REFLECT( graphene::wallet::operation_detail,
             (memo)(description)(op) )
 
 FC_API( graphene::wallet::wallet_api,
@@ -1560,6 +1717,9 @@ FC_API( graphene::wallet::wallet_api,
         (list_accounts)
         (list_account_balances)
         (list_assets)
+        (list_license_types_by_name)
+        (list_license_types_by_amount)
+        (list_license_requests_by_expiration)
         (import_key)
         (import_accounts)
         (import_account_keys)
@@ -1647,5 +1807,13 @@ FC_API( graphene::wallet::wallet_api,
         (blind_transfer)
         (blind_history)
         (receive_blind_transfer)
+        // Licenses:
+        (create_license_type_with_policy_flags)
+        (create_license_type_standard)
+        (create_license_type_chartered)
+        (issue_license)
+        (deny_license_request)
+        // Cycles:
+        (get_account_cycle_balance)
         (get_order_book)
       )
diff --git a/libraries/wallet/wallet.cpp b/libraries/wallet/wallet.cpp
index 3cec70d..5543a36 100644
--- a/libraries/wallet/wallet.cpp
+++ b/libraries/wallet/wallet.cpp
@@ -602,6 +602,7 @@ public:
    {
       return get_account(account_name_or_id).get_id();
    }
+
    optional<asset_object> find_asset(asset_id_type id)const
    {
       auto rec = _remote_db->get_assets({id}).front();
@@ -609,6 +610,7 @@ public:
          _asset_cache[id] = *rec;
       return rec;
    }
+
    optional<asset_object> find_asset(string asset_symbol_or_id)const
    {
       FC_ASSERT( asset_symbol_or_id.size() > 0 );
@@ -630,6 +632,7 @@ public:
          return rec;
       }
    }
+
    asset_object get_asset(asset_id_type id)const
    {
       auto opt = find_asset(id);
@@ -654,6 +657,17 @@ public:
       return opt_asset[0]->id;
    }
 
+   license_type_id_type get_license_type_id(string str_or_id) const
+   {
+      FC_ASSERT( str_or_id.size() > 0 );
+      vector<optional<license_type_object>> opt_license_type;
+      if( std::isdigit( str_or_id.front() ) )
+         return fc::variant(str_or_id).as<license_type_id_type>();
+      opt_license_type = _remote_db->lookup_license_type_names( {str_or_id} );
+      FC_ASSERT( (opt_license_type.size() > 0) && (opt_license_type[0].valid()) );
+      return opt_license_type[0]->id;
+   }
+
    string                            get_wallet_filename() const
    {
       return _wallet_filename;
@@ -2404,6 +2418,197 @@ public:
       return sign_transaction(tx, broadcast);
    }
 
+   /////////////////////////////
+   //                         //
+   // LICENSES:               //
+   //                         //
+   /////////////////////////////
+
+   // INTERNAL METHODS:
+
+   optional<license_type_object> find_license_type(license_type_id_type id)const
+   {
+      auto rec = _remote_db->get_license_types({id}).front();
+      if( rec )
+         _license_type_cache[id] = *rec;
+      return rec;
+   }
+
+   optional<license_type_object> find_license_type(string str_or_id)const
+   {
+      FC_ASSERT( str_or_id.size() > 0 );
+
+      if( auto id = maybe_id<license_type_id_type>(str_or_id) )
+      {
+         // It's an ID
+         return find_license_type(*id);
+      } else {
+         // It's a name
+         auto rec = _remote_db->lookup_license_type_names({str_or_id}).front();
+         if( rec )
+         {
+            if( rec->name != str_or_id )
+               return optional<license_type_object>();
+
+            _license_type_cache[rec->id] = *rec;
+         }
+         return rec;
+      }
+   }
+
+   license_type_object get_license_type(license_type_id_type id)const
+   {
+      auto opt = find_license_type(id);
+      FC_ASSERT(opt);
+      return *opt;
+   }
+
+   license_type_object get_license_type(string str_or_id)const
+   {
+      auto opt = find_license_type(str_or_id);
+      FC_ASSERT(opt);
+      return *opt;
+   }
+
+   license_request_object get_license_request(string id_str)const
+   {
+      // TODO: fix this in a template method.
+      auto id_opt = maybe_id<license_request_id_type>( id_str );
+      FC_ASSERT( id_opt );
+      auto opt = _remote_db->get_license_requests({*id_opt}).front();
+      FC_ASSERT( opt );
+      return *opt;
+   }
+
+   // LICENSE CREATION:
+
+   /**
+    * Create a license type, set all policy flags manually.
+    * @param  lic_authenticator MUST be license authenticator account.
+    * @param  name              Name of the license, unique.
+    * @param  amount            Amount of cycles the license grants.
+    * @param  upgrades          Number of upgrades
+    * @param  policy_flags      Policy flags, raw.
+    * @param  broadcast         true broadcast the transaction.
+    * @return                   signed version of the transaction.
+    */
+   signed_transaction create_license_type_with_policy_flags(const string& lic_authenticator,
+                                                            const string& name,
+                                                            share_type amount,
+                                                            uint8_t upgrades,
+                                                            uint32_t policy_flags,
+                                                            bool broadcast /* false */)
+   {
+      auto auth_acc = this->get_account( lic_authenticator );
+
+      FC_ASSERT( upgrades <= GRAPHENE_MAX_LICENSE_UPGRADE_COUNT );
+      FC_ASSERT( !find_license_type(name).valid(), "License with this name already exists!" );
+
+      license_type_create_operation op;
+      op.license_authentication_account = auth_acc.id;
+      op.name = name;
+      op.amount = amount;
+      op.upgrades = upgrades;
+      op.policy_flags = policy_flags;
+
+      signed_transaction tx;
+      tx.operations.push_back(op);
+      set_operation_fees( tx, _remote_db->get_global_properties().parameters.current_fees);
+      tx.validate();
+
+      return sign_transaction( tx, broadcast );
+   }
+
+   /**
+    * Edit an existing license type.
+    * @param  lic_authenticator MUST be the license authenticator.
+    * @param  name              New name of the license.
+    * @param  amount            New amount.
+    * @param  upgrades          New upgrade count.
+    * @param  policy_flags      New policy flags.
+    * @param  broadcast         true if you wish to broadcast the transaction.
+    * @return                   Signed version of the transaction.
+    */
+   signed_transaction edit_license_type(const string& lic_authenticator,
+                                        const string& name,
+                                        share_type amount,
+                                        uint8_t upgrades,
+                                        uint32_t policy_flags,
+                                        bool broadcast /* false */)
+   {
+      auto auth_acc = this->get_account( lic_authenticator );
+
+      FC_ASSERT( upgrades <= GRAPHENE_MAX_LICENSE_UPGRADE_COUNT );
+      FC_ASSERT( !find_license_type(name).valid(), "License with this name already exists!" );
+
+      // TODO: figure out how to make every setting optional.
+      license_type_edit_operation op;
+      op.license_authentication_account = auth_acc.id;
+      op.name = name;
+      op.amount = amount;
+      op.upgrades = upgrades;
+      op.policy_flags = policy_flags;
+
+      signed_transaction tx;
+      tx.operations.push_back(op);
+      set_operation_fees( tx, _remote_db->get_global_properties().parameters.current_fees);
+      tx.validate();
+
+      return sign_transaction( tx, broadcast );
+   }
+
+   /**
+    * Issue a license to an account. This will create the license request that can be denied by the license
+    * authentication authority.  Only the license issuing authority can do this.
+    * @param  issuer    This MUST be the license issuing authority.
+    * @param  account   Account to benefit the license.
+    * @param  license   License type id to be issued.
+    * @param  broadcast true if you wish to broadcast the transaction.
+    * @return           Signed version of the transaction.
+    */
+   signed_transaction issue_license(
+      const string& issuer,
+      const string& account,
+      const string& license,
+      optional<frequency_type> account_frequency,
+      bool broadcast)
+   {
+      auto issuer_account = this->get_account( issuer );
+      auto beneficiary = get_account( account );
+      auto new_license = get_license_type( license );
+
+      license_request_operation op;
+
+      op.license_issuing_account = issuer_account.id;
+      op.account = beneficiary.id;
+      op.license = new_license.id;
+      op.account_frequency = account_frequency;
+
+      signed_transaction tx;
+      tx.operations.push_back(op);
+      set_operation_fees( tx, _remote_db->get_global_properties().parameters.current_fees );
+      tx.validate();
+
+      return sign_transaction( tx, broadcast );
+   }
+
+   signed_transaction deny_license_request(const string& authenticator, const string& req_id, bool broadcast)
+   {
+      auto authenticator_account = this->get_account( authenticator );
+      auto request = get_license_request( req_id );
+
+      license_deny_operation op;
+
+      op.license_authentication_account = authenticator_account.id;
+      op.request = request.id;
+
+      signed_transaction tx;
+      tx.operations.push_back( op );
+      set_operation_fees( tx, _remote_db->get_global_properties().parameters.current_fees );
+
+      return sign_transaction( tx, broadcast );
+   }
+
    void dbg_make_uia(string creator, string symbol)
    {
       asset_options opts;
@@ -2594,6 +2799,7 @@ public:
    const string _wallet_filename_extension = ".wallet";
 
    mutable map<asset_id_type, asset_object> _asset_cache;
+   mutable map<license_type_id_type, license_type_object> _license_type_cache;
 };
 
 std::string operation_printer::fee(const asset& a)const {
@@ -2767,6 +2973,11 @@ vector<asset_object> wallet_api::list_assets(const string& lowerbound, uint32_t
    return my->_remote_db->list_assets( lowerbound, limit );
 }
 
+vector<license_request_object> wallet_api::list_license_requests_by_expiration(uint32_t limit)const
+{
+   return my->_remote_db->list_license_requests_by_expiration( limit );
+}
+
 vector<operation_detail> wallet_api::get_account_history(string name, int limit)const
 {
    vector<operation_detail> result;
@@ -4267,6 +4478,80 @@ vector<blind_receipt> wallet_api::blind_history( string key_or_account )
    return result;
 }
 
+//////////////////////////////////
+//                              //
+// LICENSES:                    //
+//                              //
+//////////////////////////////////
+
+signed_transaction wallet_api::create_license_type_with_policy_flags(const string& lic_authenticator,
+                                                                     const string& name,
+                                                                     share_type amount,
+                                                                     uint8_t upgrades,
+                                                                     uint32_t policy_flags,
+                                                                     bool broadcast /* false */)
+{
+   return my->create_license_type_with_policy_flags( lic_authenticator, name, amount, upgrades, policy_flags, broadcast );
+}
+
+signed_transaction wallet_api::create_license_type_standard(const string& lic_authenticator,
+                                                            const string& name,
+                                                            share_type amount,
+                                                            uint8_t upgrades,
+                                                            bool broadcast /* false */)
+{
+   auto policy_flags = 0;  // No policy flags are set.
+   return my->create_license_type_with_policy_flags(lic_authenticator,
+                                                    name,
+                                                    amount,
+                                                    upgrades,
+                                                    policy_flags,
+                                                    broadcast);
+}
+
+signed_transaction wallet_api::create_license_type_chartered(const string& lic_authenticator,
+                                                             const string& name,
+                                                             share_type amount,
+                                                             uint8_t upgrades,
+                                                             bool broadcast /* false */)
+{
+   auto policy_flags = CYCLE_POLICY_CHARTER_MASK;
+   return my->create_license_type_with_policy_flags(lic_authenticator,
+                                                    name,
+                                                    amount,
+                                                    upgrades,
+                                                    policy_flags,
+                                                    broadcast);
+}
+
+vector<license_type_object> wallet_api::list_license_types_by_name(const string& lowerbound, uint32_t limit)const
+{
+   return my->_remote_db->list_license_types_by_name( lowerbound, limit );
+}
+
+vector<license_type_object> wallet_api::list_license_types_by_amount(const uint32_t lowerbound, uint32_t limit)const
+{
+   return my->_remote_db->list_license_types_by_amount( lowerbound, limit );
+}
+
+signed_transaction wallet_api::issue_license( const string& issuer, const string& account, const string& license,
+                                              const optional<frequency_type> account_frequency, bool broadcast )
+{
+   return my->issue_license( issuer, account, license, account_frequency, broadcast );
+}
+
+signed_transaction wallet_api::deny_license_request( const string& authenticator, const string& req_id, bool broadcast)
+{
+   return my->deny_license_request( authenticator, req_id, broadcast );
+}
+
+share_type wallet_api::get_account_cycle_balance(const string& name_or_id)const
+{
+   if( auto real_id = detail::maybe_id<account_id_type>(name_or_id) )
+      return my->_remote_db->get_account_cycle_balance(*real_id);
+   return my->_remote_db->get_account_cycle_balance(get_account(name_or_id).id);
+}
+
 order_book wallet_api::get_order_book( const string& base, const string& quote, unsigned limit )
 {
    return( my->_remote_db->get_order_book( base, quote, limit ) );
diff --git a/programs/CMakeLists.txt b/programs/CMakeLists.txt
index 932e69b..48de2af 100644
--- a/programs/CMakeLists.txt
+++ b/programs/CMakeLists.txt
@@ -2,7 +2,3 @@ add_subdirectory( build_helpers )
 add_subdirectory( cli_wallet )
 add_subdirectory( genesis_util )
 add_subdirectory( witness_node )
-add_subdirectory( debug_node )
-add_subdirectory( delayed_node )
-add_subdirectory( js_operation_serializer )
-add_subdirectory( size_checker )
